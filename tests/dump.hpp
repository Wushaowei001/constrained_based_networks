#include "constraints.hpp"
std::string create_model(){
using namespace constrained_based_networks;
auto pool = Pool::getInstance();
new DataService("Dev::Bus::CAN::BusSrv");
new DataService("Dev::Bus::CAN::BusOutSrv");
new DataService("Localization::HoughSrv");
new DataService("Base::GroundDistanceSrv");
new DataService("Base::DVLSrv");
new DataService("Dev::Bus::CAN::BusInSrv");
new DataService("Base::VelocitySrv");
new DataService("Base::PoseDeltaSrv");
new DataService("Base::GlobalPoseSrv");
new DataService("Base::RelativePoseSrv");
new DataService("Base::TransformationSrv");
new DataService("Dev::Bus::CAN::BusBaseSrv");
new DataService("Base::PoseSrv");
new DataService("Dev::Bus::CAN");
new DataService("Base::OrientationWithZSrv");
new DataService("Base::ZProviderSrv");
new DataService("Base::OrientationSrv");
new DataService("Base::PositionSrv");
new DataService("Base::RotationSrv");
new DataService("Dev::Sensors::DepthReaderAvalon");
new DataService("Base::WorldXYZPositionControllerSrv");
new DataService("Base::WorldZRollPitchYawSrv");
new DataService("Base::WorldXYVelocityControllerSrv");
new DataService("Base::WorldYPositionXVelocityControllerSrv");
new DataService("Base::WorldXYPositionControllerSrv");
new DataService("Base::WorldXYZRollPitchYawControllerSrv");
new DataService("Base::WorldXYZRollPitchYawControlledSystemSrv");
new DataService("Dev::Sensors::KVH::DSP3000");
new DataService("Base::SonarImageProviderSrv");
new DataService("Dev::Profiling");
new DataService("Dev::Echosounder");
new DataService("Dev::Sensors::BlueView");
new DataService("Dev::Micron");
new DataService("Dev::Sensors::Cameras::Vrmagic");
new DataService("Dev::Actuators::Dynamixel");
new DataService("Dev::Actuators::PTU");
new DataService("Dev::Sensors::TimestamperDev");
new DataService("Dev::Sensors::Cameras::USB");
new DataService("Dev::Sensors::Cameras::Prosilica");
new DataService("Dev::Sensors::Cameras::Firewire");
new DataService("Dev::Sensors::XsensAHRS");
new DataService("Dev::Sensors::Hokuyo");
new DataService("Dev::Sensors::GPS");
new DataService("Dev::Controldev::Mouse3D");
new DataService("Base::PointcloudProviderSrv");
new DataService("Dev::Controldev::Joystick");
new DataService("Base::SonarScanProviderSrv");
new DataService("Dev::Sensors::Hbridge");
new DataService("Base::LaserRangeFinderSrv");
new DataService("Dev::Actuators::Hbridge");
new DataService("Base::DistanceImageProviderSrv");
new DataService("Base::StereoPairProviderSrv");
new DataService("Base::ImageProviderSrv");
new DataService("Base::CalibratedIMUSensorsSrv");
new DataService("Base::CompensatedIMUSensorsSrv");
new DataService("Base::IMUSensorsSrv");
new DataService("Base::RawCommandControlledSystemSrv");
new DataService("Base::ImageConsumerSrv");
new DataService("Base::RawCommandControllerSrv");
new DataService("Base::TimestampInputSrv");
new DataService("Base::TimestamperSrv");
new DataService("Base::RawCommandCommandConsumerSrv");
new DataService("Base::AUVRelativeMotionControllerSrv");
new DataService("Base::AUVRelativeMotionCommandConsumerSrv");
new DataService("Base::AUVMotionControlledSystemSrv");
new DataService("Dev::Bus::CAN::ClientSrv");
new DataService("Dev::Bus::CAN::ClientInSrv");
new DataService("Base::AUVMotionControllerSrv");
new DataService("Base::AUVMotionCommandConsumerSrv");
new DataService("Dev::Bus::CAN::ClientOutSrv");
new DataService("Base::JointsControlledSystemSrv");
new DataService("Base::JointsControllerSrv");
new DataService("Base::JointsCommandSrv");
new DataService("Base::JointsStatusSrv");
new DataService("Base::JointsCommandConsumerSrv");
new DataService("Base::ControlledSystemSrv");
new DataService("Base::ControllerSrv");
new DataService("Base::MapSrv");
new DataService("Base::OrientationToCorrectSrv");
new DataService("Auv::StructuredLightPairSrv");
new DataService("Auv::SoundSourceDirectionSrv");
new DataService("WallServoing::WallOrientationSrv");
new DataService("Auv::ModemConnectionSrv");
new DataService("Base::AUVRelativeMotionControlledSystemSrv");
new DataService("Dev::SystemStatus");
new DataService("Dev::ASVModem");
new DataService("Dev::Sensors::Modem");
new DataService("Dev::Sensors::Battery");
new DataService("Dev::Actuators::Lights");
{
auto t = new Task("UwParticleLocalization::Task");
(void)t;
t->addEvent("above_surface");
t->addEvent("invalid_values");
t->addEvent("localizing");
t->addEvent("no_hough");
t->addEvent("no_joints_no_dvl");
t->addEvent("no_orientation");
t->addEvent("no_sonar");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("debug", ConfigurationModel::BOOL);
	t->addProperty("particle_number", ConfigurationModel::INT);
	t->addProperty("minimum_depth", ConfigurationModel::DOUBLE);
	t->addProperty("hough_interspersal_ratio", ConfigurationModel::DOUBLE);
	t->addProperty("hough_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("hough_timeout_interspersal", ConfigurationModel::DOUBLE);
	t->addProperty("effective_sample_size_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("reset_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("speed_samples_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("minimum_perceptions", ConfigurationModel::INT);
	t->addProperty("yaml_map", ConfigurationModel::STRING);
	t->addProperty("yaml_depth_map", ConfigurationModel::STRING);
	t->addProperty("yaml_depth_output_map", ConfigurationModel::STRING);
	t->addProperty("sonar_maximum_distance", ConfigurationModel::DOUBLE);
	t->addProperty("sonar_minimum_distance", ConfigurationModel::DOUBLE);
	t->addProperty("sonar_covariance", ConfigurationModel::DOUBLE);
	t->addProperty("pipeline_covariance", ConfigurationModel::DOUBLE);
	t->addProperty("buoy_covariance", ConfigurationModel::DOUBLE);
	t->addProperty("pure_random_motion", ConfigurationModel::BOOL);
	t->addProperty("sonar_importance", ConfigurationModel::DOUBLE);
	t->addProperty("pipeline_importance", ConfigurationModel::DOUBLE);
	t->addProperty("buoy_importance", ConfigurationModel::DOUBLE);
	t->addProperty("perception_history_number", ConfigurationModel::INT);
	t->addProperty("init_sample_rejection", ConfigurationModel::INT);
	t->addProperty("orientation_offset", ConfigurationModel::DOUBLE);
	t->addProperty("filter_zeros", ConfigurationModel::BOOL);
	t->addProperty("use_markov", ConfigurationModel::BOOL);
	t->addProperty("avg_particle_position", ConfigurationModel::BOOL);
	t->addProperty("use_best_feature_only", ConfigurationModel::BOOL);
	t->addProperty("utm_relative_angle", ConfigurationModel::DOUBLE);
	t->addProperty("gps_covarianz", ConfigurationModel::DOUBLE);
	t->addProperty("gps_importance", ConfigurationModel::DOUBLE);
	t->addProperty("gps_interspersal_ratio", ConfigurationModel::DOUBLE);
	t->addProperty("sonar_vertical_angle", ConfigurationModel::DOUBLE);
	t->addProperty("sonar_covariance_reflection_factor", ConfigurationModel::DOUBLE);
	t->addProperty("sonar_covariance_corner_factor", ConfigurationModel::DOUBLE);
	t->addProperty("position_covariance_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("advanced_motion_model", ConfigurationModel::BOOL);
	t->addProperty("max_velocity_drift", ConfigurationModel::DOUBLE);
	t->addProperty("param_length", ConfigurationModel::DOUBLE);
	t->addProperty("param_radius", ConfigurationModel::DOUBLE);
	t->addProperty("param_mass", ConfigurationModel::DOUBLE);
	t->addProperty("param_thrusterVoltage", ConfigurationModel::DOUBLE);
	t->addProperty("param_floating", ConfigurationModel::BOOL);
	t->addProperty("use_slam", ConfigurationModel::BOOL);
	t->addProperty("use_mapping_only", ConfigurationModel::BOOL);
	t->addProperty("single_depth_map", ConfigurationModel::BOOL);
	t->addProperty("echosounder_variance", ConfigurationModel::DOUBLE);
	t->addProperty("feature_weight_reduction", ConfigurationModel::DOUBLE);
	t->addProperty("feature_observation_range", ConfigurationModel::DOUBLE);
	t->addProperty("feature_observation_minimum_range", ConfigurationModel::DOUBLE);
	t->addProperty("feature_grid_resolution", ConfigurationModel::DOUBLE);
	t->addProperty("feature_filter_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("feature_confidence", ConfigurationModel::DOUBLE);
	t->addProperty("feature_empty_cell_confidence", ConfigurationModel::DOUBLE);
	t->addProperty("feature_confidence_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("feature_output_confidence_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("feature_observation_count_threshold", ConfigurationModel::INT);
	t->addProperty("aggregator_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("stream_aligner_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("laser_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("orientation_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("speed_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("thruster_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("pipeline_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("gps_pose_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("echosounder_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("obstacle_samples_period", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("WallServoing::SonarServoing");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("wall_distance", ConfigurationModel::DOUBLE);
	t->addProperty("fixed_depth", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_speed", ConfigurationModel::DOUBLE);
	t->addProperty("exploration_speed", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Buoy::Survey");
(void)t;
t->addEvent("angle_arrived");
t->addEvent("buoy_arrived");
t->addEvent("buoy_detected");
t->addEvent("buoy_lost");
t->addEvent("buoy_search");
t->addEvent("cutting");
t->addEvent("cutting_error");
t->addEvent("cutting_success");
t->addEvent("moving_to_cutting_distance");
t->addEvent("re_searching_buoy");
t->addEvent("strafe_error");
t->addEvent("strafe_finished");
t->addEvent("strafe_to_angle");
t->addEvent("strafing");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("max_buoy_distance", ConfigurationModel::DOUBLE);
	t->addProperty("strafe_intensity", ConfigurationModel::DOUBLE);
	t->addProperty("steps", ConfigurationModel::INT);
	t->addProperty("lost_timeout", ConfigurationModel::INT);
	t->addProperty("good_y_z", ConfigurationModel::DOUBLE);
	t->addProperty("good_x", ConfigurationModel::DOUBLE);
	t->addProperty("buoy_depth", ConfigurationModel::DOUBLE);
	t->addProperty("headingFactor", ConfigurationModel::DOUBLE);
	t->addProperty("headingModulation", ConfigurationModel::DOUBLE);
	t->addProperty("maxX", ConfigurationModel::DOUBLE);
	t->addProperty("cutting_time", ConfigurationModel::INT);
	t->addProperty("cutting_hight", ConfigurationModel::DOUBLE);
	t->addProperty("strafe_angle", ConfigurationModel::DOUBLE);
	t->addProperty("strafe_around", ConfigurationModel::BOOL);
	t->addProperty("cutting_wait_time", ConfigurationModel::INT);
	t->addProperty("z_offset", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Dynamixel::Task");
(void)t;
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Actuators::Dynamixel");
t->addFullfillment("Base::TransformationSrv");
	t->addProperty("zero_offset", ConfigurationModel::DOUBLE);
	t->addProperty("lower_sweep_angle", ConfigurationModel::DOUBLE);
	t->addProperty("upper_sweep_angle", ConfigurationModel::DOUBLE);
	t->addProperty("moving_speed", ConfigurationModel::DOUBLE);
	t->addProperty("upper_frame", ConfigurationModel::STRING);
	t->addProperty("lower_frame", ConfigurationModel::STRING);
	t->addProperty("device", ConfigurationModel::STRING);
	t->addProperty("servo_id", ConfigurationModel::INT);
	t->addProperty("cw_slope", ConfigurationModel::INT);
	t->addProperty("cw_margin", ConfigurationModel::INT);
	t->addProperty("ccw_margin", ConfigurationModel::INT);
	t->addProperty("ccw_slope", ConfigurationModel::INT);
	t->addProperty("punch", ConfigurationModel::INT);
	t->addProperty("torque_limit", ConfigurationModel::INT);
	t->addProperty("upperFrameName", ConfigurationModel::STRING);
	t->addProperty("lowerFrameName", ConfigurationModel::STRING);
}
{
auto t = new Task("SonarFeatureDetector::Task");
(void)t;
t->addEvent("building_map");
t->addEvent("not_enough_targets");
t->addEvent("reached_target");
t->addEvent("servoing_finished");
t->addEvent("target_servoing");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("minimum_wall_distance", ConfigurationModel::DOUBLE);
	t->addProperty("filter_border_structures", ConfigurationModel::BOOL);
	t->addProperty("optimal_object_size", ConfigurationModel::DOUBLE);
	t->addProperty("minimum_object_cells", ConfigurationModel::INT);
	t->addProperty("minimum_number_of_targets", ConfigurationModel::INT);
	t->addProperty("confidence_weight", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_depth", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("WallServoing::WallServoing");
(void)t;
t->addEvent("corner");
t->addEvent("get_initial_wall_search_direction");
t->addEvent("initial_wall_search");
t->addEvent("leaving_corner");
t->addEvent("leaving_get_initial_wall_search_direction");
t->addEvent("wall_servoing");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("servoing_direction", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_depth", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_distance", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_speed", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_factor", ConfigurationModel::DOUBLE);
	t->addProperty("correction_speed", ConfigurationModel::DOUBLE);
	t->addProperty("correction_factor", ConfigurationModel::DOUBLE);
	t->addProperty("search_direction", ConfigurationModel::DOUBLE);
	t->addProperty("direction_clockwise", ConfigurationModel::BOOL);
}
{
auto t = new Task("Canbus::InterfaceTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("PipelineInspection::ColorFilter");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("green_threshold", ConfigurationModel::INT);
	t->addProperty("diff_threshold", ConfigurationModel::INT);
}
{
auto t = new Task("WallServoing::WallDetector");
(void)t;
t->addEvent("wall_found");
t->addEvent("wall_searching");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("wall_direction", ConfigurationModel::DOUBLE);
	t->addProperty("opening_angle", ConfigurationModel::DOUBLE);
	t->addProperty("fading_out_factor", ConfigurationModel::DOUBLE);
	t->addProperty("use_motion_model", ConfigurationModel::BOOL);
	t->addProperty("wall_estimation_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("offset", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Canbus::Task");
(void)t;
t->addEvent("can_error");
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Bus::CAN");
t->addFullfillment("Dev::Bus::CAN::BusInSrv");
t->addFullfillment("Dev::Bus::CAN::BusBaseSrv");
	t->addProperty("device", ConfigurationModel::STRING);
	t->addProperty("checkBusOkInterval", ConfigurationModel::INT);
	t->addProperty("statsInterval", ConfigurationModel::INT);
}
{
auto t = new Task("Transformer::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("PipelineInspection::Inspection");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("invert_z", ConfigurationModel::BOOL);
	t->addProperty("laser_left_boundary", ConfigurationModel::DOUBLE);
	t->addProperty("laser_right_boundary", ConfigurationModel::DOUBLE);
	t->addProperty("max_pipe_angle", ConfigurationModel::DOUBLE);
	t->addProperty("min_pipe_confidence", ConfigurationModel::DOUBLE);
	t->addProperty("buffer_size", ConfigurationModel::INT);
	t->addProperty("use_second_minimizer", ConfigurationModel::BOOL);
	t->addProperty("no_motion", ConfigurationModel::BOOL);
	t->addProperty("use_velocity", ConfigurationModel::BOOL);
	t->addProperty("relative_map", ConfigurationModel::BOOL);
	t->addProperty("matcher_parameter_tolerance", ConfigurationModel::DOUBLE);
	t->addProperty("matcher_value_tolerance", ConfigurationModel::DOUBLE);
	t->addProperty("matcher_iterations", ConfigurationModel::INT);
	t->addProperty("matcher_pipe_up", ConfigurationModel::BOOL);
	t->addProperty("matcher_variance_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("z_offset", ConfigurationModel::DOUBLE);
	t->addProperty("pipe_radius_h", ConfigurationModel::DOUBLE);
	t->addProperty("pipe_radius_v", ConfigurationModel::DOUBLE);
	t->addProperty("pipe_tolerance_h", ConfigurationModel::DOUBLE);
	t->addProperty("pipe_tolerance_v", ConfigurationModel::DOUBLE);
	t->addProperty("pipe_min_radius", ConfigurationModel::DOUBLE);
	t->addProperty("movement_factor", ConfigurationModel::DOUBLE);
	t->addProperty("debug", ConfigurationModel::BOOL);
}
{
auto t = new Task("PipelineInspection::LaserSimulation");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("variance", ConfigurationModel::DOUBLE);
	t->addProperty("line_height", ConfigurationModel::DOUBLE);
	t->addProperty("line_length", ConfigurationModel::DOUBLE);
	t->addProperty("pipe_height", ConfigurationModel::DOUBLE);
	t->addProperty("pipe_width", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Logger::Logger");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("file", ConfigurationModel::STRING);
	t->addProperty("overwrite_existing_files", ConfigurationModel::BOOL);
}
{
auto t = new Task("DepthReader::Task");
(void)t;
t->addEvent("water_ingress");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::DepthReaderAvalon");
t->addFullfillment("Dev::Bus::CAN::ClientOutSrv");
t->addFullfillment("Dev::Bus::CAN::ClientInSrv");
t->addFullfillment("Base::ZProviderSrv");
	t->addProperty("can_id", ConfigurationModel::INT);
	t->addProperty("filter_param_internal_pressure", ConfigurationModel::INT);
	t->addProperty("filter_param_temperature", ConfigurationModel::INT);
	t->addProperty("filter_param_water", ConfigurationModel::INT);
	t->addProperty("filter_param_external_pressure", ConfigurationModel::INT);
	t->addProperty("externalPressureFactor", ConfigurationModel::DOUBLE);
	t->addProperty("internalPressureFactor", ConfigurationModel::DOUBLE);
	t->addProperty("internalPressureOffset", ConfigurationModel::DOUBLE);
	t->addProperty("temperatureFactor", ConfigurationModel::DOUBLE);
	t->addProperty("temperatureOffset", ConfigurationModel::DOUBLE);
	t->addProperty("smooth_factor", ConfigurationModel::DOUBLE);
	t->addProperty("covariance_depth", ConfigurationModel::DOUBLE);
	t->addProperty("covariance_depth_velocity", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("WallOrientationCorrection::OrientationInMap");
(void)t;
t->addEvent("missing_transformation");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("orientation_in_world_period", ConfigurationModel::DOUBLE);
	t->addProperty("map_frame", ConfigurationModel::STRING);
	t->addProperty("world_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("WallOrientationCorrection::Task");
(void)t;
t->addEvent("estimate_wall_orientation");
t->addEvent("missing_transformation");
t->addEvent("valid_wall_fix");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("ransac_min_inlier", ConfigurationModel::DOUBLE);
	t->addProperty("ransac_max_distance", ConfigurationModel::DOUBLE);
	t->addProperty("wall_distance_sigma", ConfigurationModel::DOUBLE);
	t->addProperty("wall_angle_sigma", ConfigurationModel::DOUBLE);
	t->addProperty("wall_candidate_count", ConfigurationModel::INT);
	t->addProperty("target_frame", ConfigurationModel::STRING);
	t->addProperty("enable_debug", ConfigurationModel::BOOL);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("sonarbeam_feature_period", ConfigurationModel::DOUBLE);
	t->addProperty("orientation_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("sonar_frame", ConfigurationModel::STRING);
	t->addProperty("body_frame", ConfigurationModel::STRING);
	t->addProperty("odometry_frame", ConfigurationModel::STRING);
	t->addProperty("wall_frame", ConfigurationModel::STRING);
	t->addProperty("world_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("StructuredLight::Calibration");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("aggregator_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("stream_aligner_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("laser_scan_period", ConfigurationModel::DOUBLE);
	t->addProperty("calibration_period", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("StructuredLight::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("display_diff", ConfigurationModel::BOOL);
	t->addProperty("debug_level", ConfigurationModel::INT);
}
{
auto t = new Task("AuvControl::OptimalHeadingController");
(void)t;
t->addEvent("wait_for_orientation_sample");
t->addEvent("controlling");
t->addEvent("controlling_unsafe");
t->addEvent("input_colliding");
t->addEvent("input_missing");
t->addEvent("input_unexpected");
t->addEvent("timeout");
t->addEvent("wait_for_connected_input_port");
t->addEvent("wait_for_input");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("keep_position_on_exception", ConfigurationModel::BOOL);
	t->addProperty("nan_on_keep_position", ConfigurationModel::BOOL);
	t->addProperty("timeout_in", ConfigurationModel::DOUBLE);
	t->addProperty("timeout_cascade", ConfigurationModel::DOUBLE);
	t->addProperty("safe_mode", ConfigurationModel::BOOL);
	t->addProperty("optimal_heading", ConfigurationModel::DOUBLE);
	t->addProperty("optimal_heading_distance", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("AuvControl::MotionCommand2DConverter");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("FogKvh::Dsp3000Task");
(void)t;
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::KVH::DSP3000");
t->addFullfillment("Base::RotationSrv");
	t->addProperty("timeout", ConfigurationModel::INT);
	t->addProperty("port", ConfigurationModel::STRING);
}
{
auto t = new Task("RawControlCommandConverter::Position");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("AuvControl::WaypointNavigator");
(void)t;
t->addEvent("following_waypoints");
t->addEvent("keep_waypoint");
t->addEvent("pose_sample_missing");
t->addEvent("wait_for_waypoints");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("AuvControl::ConstantCommandGroundAvoidance");
(void)t;
t->addEvent("invalid_depth_reading");
t->addEvent("invalid_negative_altimeter_reading");
t->addEvent("invalid_target_depth_config");
t->addEvent("no_altimeter_reading");
t->addEvent("no_depth_reading");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("use_as_constant_task", ConfigurationModel::BOOL);
	t->addProperty("minimal_ground_distance", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("RawControlCommandConverter::Movement");
(void)t;
t->addEvent("got_pose_without_depth");
t->addEvent("should_do_ground_following_without_ground_distance");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("diveScale", ConfigurationModel::DOUBLE);
	t->addProperty("turnScale", ConfigurationModel::DOUBLE);
	t->addProperty("absolute_heading", ConfigurationModel::BOOL);
	t->addProperty("do_ground_following", ConfigurationModel::BOOL);
	t->addProperty("delta_depth_control", ConfigurationModel::BOOL);
}
{
auto t = new Task("AuvControl::ConstantCommandGroundFollower");
(void)t;
t->addEvent("invalid_depth_reading");
t->addEvent("invalid_negative_altimeter_reading");
t->addEvent("invalid_target_depth_config");
t->addEvent("no_altimeter_reading");
t->addEvent("no_depth_reading");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("use_as_constant_task", ConfigurationModel::BOOL);
}
{
auto t = new Task("AuvControl::ConstantCommand");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::WorldXYZRollPitchYawControllerSrv");
}
{
auto t = new Task("SonarBlueview::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::BlueView");
t->addFullfillment("Base::ImageProviderSrv");
	t->addProperty("hostname", ConfigurationModel::STRING);
	t->addProperty("port", ConfigurationModel::INT);
	t->addProperty("minRange", ConfigurationModel::DOUBLE);
	t->addProperty("maxRange", ConfigurationModel::DOUBLE);
	t->addProperty("gain", ConfigurationModel::DOUBLE);
	t->addProperty("tvgSlope", ConfigurationModel::DOUBLE);
	t->addProperty("rangeRes", ConfigurationModel::DOUBLE);
	t->addProperty("fluidType", ConfigurationModel::INT);
	t->addProperty("soundSpeed", ConfigurationModel::INT);
	t->addProperty("imageRes", ConfigurationModel::INT);
	t->addProperty("tx", ConfigurationModel::INT);
}
{
auto t = new Task("SonarTritech::Profiling");
(void)t;
t->addEvent("invalid_configuration");
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("port", ConfigurationModel::STRING);
	t->addProperty("baudrate", ConfigurationModel::INT);
	t->addProperty("read_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("write_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("configure_timeout", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("SonarFeatureEstimator::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("proportional_value_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("signal_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("derivative_history_length", ConfigurationModel::INT);
	t->addProperty("feature_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("best_values_size", ConfigurationModel::INT);
	t->addProperty("signal_balancing", ConfigurationModel::DOUBLE);
	t->addProperty("plain_length", ConfigurationModel::DOUBLE);
	t->addProperty("plain_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("enforce_line_rate", ConfigurationModel::DOUBLE);
	t->addProperty("minimum_enforce_line_value", ConfigurationModel::DOUBLE);
	t->addProperty("enforce_line_beam_covariance", ConfigurationModel::DOUBLE);
	t->addProperty("avalon_boundary_box_size", ConfigurationModel::DOUBLE);
	t->addProperty("enable_debug_output", ConfigurationModel::BOOL);
}
{
auto t = new Task("SonarTritech::Echosounder");
(void)t;
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Echosounder");
t->addFullfillment("Base::GroundDistanceSrv");
	t->addProperty("ground_frame", ConfigurationModel::STRING);
	t->addProperty("port", ConfigurationModel::STRING);
	t->addProperty("baudrate", ConfigurationModel::INT);
	t->addProperty("echo_sounder_timeout", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("AuvControl::AccelerationController");
(void)t;
t->addEvent("invalid_name_in_limits");
t->addEvent("wrong_size_of_controlmodes");
t->addEvent("wrong_size_of_limits");
t->addEvent("wrong_size_of_names");
t->addEvent("controlling");
t->addEvent("controlling_unsafe");
t->addEvent("input_colliding");
t->addEvent("input_missing");
t->addEvent("input_unexpected");
t->addEvent("timeout");
t->addEvent("wait_for_connected_input_port");
t->addEvent("wait_for_input");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("keep_position_on_exception", ConfigurationModel::BOOL);
	t->addProperty("nan_on_keep_position", ConfigurationModel::BOOL);
	t->addProperty("timeout_in", ConfigurationModel::DOUBLE);
	t->addProperty("timeout_cascade", ConfigurationModel::DOUBLE);
	t->addProperty("safe_mode", ConfigurationModel::BOOL);
}
{
auto t = new Task("SonarTritech::Micron");
(void)t;
t->addEvent("invalid_configuration");
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Micron");
t->addFullfillment("Base::GroundDistanceSrv");
t->addFullfillment("Base::SonarScanProviderSrv");
	t->addProperty("ground_frame", ConfigurationModel::STRING);
	t->addProperty("port", ConfigurationModel::STRING);
	t->addProperty("baudrate", ConfigurationModel::INT);
	t->addProperty("read_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("write_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("configure_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("echo_sounder_timeout", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("FrameDemultiplexer::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("used_sequences", ConfigurationModel::INT);
}
{
auto t = new Task("AuvControl::AlignedToBody");
(void)t;
t->addEvent("orientation_sample_invalid");
t->addEvent("wait_for_orientation_sample");
t->addEvent("controlling");
t->addEvent("controlling_unsafe");
t->addEvent("input_colliding");
t->addEvent("input_missing");
t->addEvent("input_unexpected");
t->addEvent("timeout");
t->addEvent("wait_for_connected_input_port");
t->addEvent("wait_for_input");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("keep_position_on_exception", ConfigurationModel::BOOL);
	t->addProperty("nan_on_keep_position", ConfigurationModel::BOOL);
	t->addProperty("timeout_in", ConfigurationModel::DOUBLE);
	t->addProperty("timeout_cascade", ConfigurationModel::DOUBLE);
	t->addProperty("safe_mode", ConfigurationModel::BOOL);
	t->addProperty("timeout_orientation", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("AuvControl::WorldToAligned");
(void)t;
t->addEvent("pose_sample_invalid");
t->addEvent("wait_for_pose_sample");
t->addEvent("controlling");
t->addEvent("controlling_unsafe");
t->addEvent("input_colliding");
t->addEvent("input_missing");
t->addEvent("input_unexpected");
t->addEvent("timeout");
t->addEvent("wait_for_connected_input_port");
t->addEvent("wait_for_input");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("keep_position_on_exception", ConfigurationModel::BOOL);
	t->addProperty("nan_on_keep_position", ConfigurationModel::BOOL);
	t->addProperty("timeout_in", ConfigurationModel::DOUBLE);
	t->addProperty("timeout_cascade", ConfigurationModel::DOUBLE);
	t->addProperty("safe_mode", ConfigurationModel::BOOL);
	t->addProperty("position_control", ConfigurationModel::BOOL);
}
{
auto t = new Task("CameraUnicap::CameraTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("camera_id", ConfigurationModel::INT);
	t->addProperty("width", ConfigurationModel::INT);
	t->addProperty("height", ConfigurationModel::INT);
	t->addProperty("output_format", ConfigurationModel::STRING);
	t->addProperty("frame_buffer_size", ConfigurationModel::INT);
	t->addProperty("fps", ConfigurationModel::INT);
	t->addProperty("whitebalance_mode", ConfigurationModel::STRING);
	t->addProperty("whitebalance_blue", ConfigurationModel::INT);
	t->addProperty("whitebalance_red", ConfigurationModel::INT);
	t->addProperty("gain", ConfigurationModel::INT);
	t->addProperty("exposure", ConfigurationModel::INT);
	t->addProperty("trigger_mode", ConfigurationModel::STRING);
	t->addProperty("binning", ConfigurationModel::INT);
}
{
auto t = new Task("AuvControl::PIDController");
(void)t;
t->addEvent("pose_sample_invalid");
t->addEvent("unsure_pose_sample");
t->addEvent("wait_for_pose_sample");
t->addEvent("controlling");
t->addEvent("controlling_unsafe");
t->addEvent("input_colliding");
t->addEvent("input_missing");
t->addEvent("input_unexpected");
t->addEvent("timeout");
t->addEvent("wait_for_connected_input_port");
t->addEvent("wait_for_input");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("keep_position_on_exception", ConfigurationModel::BOOL);
	t->addProperty("nan_on_keep_position", ConfigurationModel::BOOL);
	t->addProperty("timeout_in", ConfigurationModel::DOUBLE);
	t->addProperty("timeout_cascade", ConfigurationModel::DOUBLE);
	t->addProperty("safe_mode", ConfigurationModel::BOOL);
	t->addProperty("use_parallel_pid_settings", ConfigurationModel::BOOL);
	t->addProperty("variance_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("position_control", ConfigurationModel::BOOL);
	t->addProperty("world_frame", ConfigurationModel::BOOL);
}
{
auto t = new Task("PoseEstimation::VehiclePoseEstimator");
(void)t;
t->addEvent("missing_transformation");
t->addEvent("transformation_alignment_failures");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("max_time_delta", ConfigurationModel::DOUBLE);
	t->addProperty("target_frame", ConfigurationModel::STRING);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("orientation_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("velocity_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("position_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("imu_frame", ConfigurationModel::STRING);
	t->addProperty("body_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("PoseEstimation::HighDelayPoseEstimator");
(void)t;
t->addEvent("missing_transformation");
t->addEvent("transformation_alignment_failures");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("max_time_delta", ConfigurationModel::DOUBLE);
	t->addProperty("target_frame", ConfigurationModel::STRING);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("pose_samples_slow_period", ConfigurationModel::DOUBLE);
	t->addProperty("xy_position_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("xy_map_frame", ConfigurationModel::STRING);
	t->addProperty("target_map_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("PoseEstimation::UWPoseEstimator");
(void)t;
t->addEvent("missing_transformation");
t->addEvent("transformation_alignment_failures");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("max_time_delta", ConfigurationModel::DOUBLE);
	t->addProperty("target_frame", ConfigurationModel::STRING);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("orientation_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("depth_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("dvl_velocity_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("model_velocity_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("lbl_position_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("xy_position_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("gps_position_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("xyz_position_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("imu_frame", ConfigurationModel::STRING);
	t->addProperty("body_frame", ConfigurationModel::STRING);
	t->addProperty("pressure_sensor_frame", ConfigurationModel::STRING);
	t->addProperty("dvl_frame", ConfigurationModel::STRING);
	t->addProperty("lbl_frame", ConfigurationModel::STRING);
	t->addProperty("gps_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("PoseEstimation::BaseTask");
(void)t;
t->addEvent("missing_transformation");
t->addEvent("transformation_alignment_failures");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("max_time_delta", ConfigurationModel::DOUBLE);
	t->addProperty("target_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("SonarWallHough::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("sensorAngularResolution", ConfigurationModel::DOUBLE);
	t->addProperty("sensorAngularTolerance", ConfigurationModel::DOUBLE);
	t->addProperty("anglesPerBin", ConfigurationModel::INT);
	t->addProperty("maxDistance", ConfigurationModel::INT);
	t->addProperty("filterThreshold", ConfigurationModel::INT);
	t->addProperty("withMinimumFilter", ConfigurationModel::BOOL);
	t->addProperty("minDistance", ConfigurationModel::DOUBLE);
	t->addProperty("distancesPerBin", ConfigurationModel::INT);
	t->addProperty("minLineVotesRatio", ConfigurationModel::DOUBLE);
	t->addProperty("angleDelta", ConfigurationModel::DOUBLE);
	t->addProperty("basinHeight", ConfigurationModel::DOUBLE);
	t->addProperty("basinWidth", ConfigurationModel::DOUBLE);
	t->addProperty("gain", ConfigurationModel::INT);
	t->addProperty("show_debug", ConfigurationModel::BOOL);
	t->addProperty("continous_write", ConfigurationModel::BOOL);
	t->addProperty("usePositionSamples", ConfigurationModel::BOOL);
	t->addProperty("correctToFirstPosition", ConfigurationModel::BOOL);
	t->addProperty("avalonSonarPose", ConfigurationModel::DOUBLE);
	t->addProperty("ignoreOrientation", ConfigurationModel::BOOL);
	t->addProperty("pos_covar", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("AuvControl::BasePIDController");
(void)t;
t->addEvent("pose_sample_invalid");
t->addEvent("unsure_pose_sample");
t->addEvent("wait_for_pose_sample");
t->addEvent("controlling");
t->addEvent("controlling_unsafe");
t->addEvent("input_colliding");
t->addEvent("input_missing");
t->addEvent("input_unexpected");
t->addEvent("timeout");
t->addEvent("wait_for_connected_input_port");
t->addEvent("wait_for_input");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("keep_position_on_exception", ConfigurationModel::BOOL);
	t->addProperty("nan_on_keep_position", ConfigurationModel::BOOL);
	t->addProperty("timeout_in", ConfigurationModel::DOUBLE);
	t->addProperty("timeout_cascade", ConfigurationModel::DOUBLE);
	t->addProperty("safe_mode", ConfigurationModel::BOOL);
	t->addProperty("use_parallel_pid_settings", ConfigurationModel::BOOL);
	t->addProperty("variance_threshold", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("AuvHelper::DepthAndOrientationFusion");
(void)t;
t->addEvent("got_invalid_depth");
t->addEvent("got_invalid_orientation");
t->addEvent("waiting_for_depth");
t->addEvent("waiting_for_orientation");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("heading_offset", ConfigurationModel::DOUBLE);
	t->addProperty("use_initial_heading", ConfigurationModel::BOOL);
	t->addProperty("depth_correction_buffer_size", ConfigurationModel::INT);
	t->addProperty("minimum_buffer_size", ConfigurationModel::INT);
	t->addProperty("ground_depth", ConfigurationModel::DOUBLE);
	t->addProperty("aggregator_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("stream_aligner_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("orientation_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("depth_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("ground_distance_period", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Controldev::Remote");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Bus::CAN::ClientInSrv");
t->addFullfillment("Dev::Controldev::Joystick");
t->addFullfillment("Base::RawCommandControllerSrv");
t->addFullfillment("Base::ControllerSrv");
}
{
auto t = new Task("Controldev::GenericRawToMotion2D");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("maxSpeed", ConfigurationModel::DOUBLE);
	t->addProperty("maxRotationSpeed", ConfigurationModel::DOUBLE);
	t->addProperty("translation_axis_deadzone", ConfigurationModel::DOUBLE);
	t->addProperty("rotation_axis_deadzone", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("XsensImu::Task");
(void)t;
t->addEvent("driver_error");
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::XsensAHRS");
t->addFullfillment("Base::CalibratedIMUSensorsSrv");
t->addFullfillment("Base::IMUSensorsSrv");
t->addFullfillment("Base::OrientationSrv");
t->addFullfillment("Base::TimestampInputSrv");
	t->addProperty("port", ConfigurationModel::STRING);
	t->addProperty("timeout", ConfigurationModel::INT);
	t->addProperty("scenario", ConfigurationModel::STRING);
	t->addProperty("imu_frame", ConfigurationModel::STRING);
	t->addProperty("world_frame", ConfigurationModel::STRING);
	t->addProperty("max_timeouts", ConfigurationModel::INT);
}
{
auto t = new Task("Controldev::RawWheelToMotion2D");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("minSpeed", ConfigurationModel::DOUBLE);
	t->addProperty("maxSpeed", ConfigurationModel::DOUBLE);
	t->addProperty("maxRotationSpeed", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("AuvControl::Base");
(void)t;
t->addEvent("controlling");
t->addEvent("controlling_unsafe");
t->addEvent("input_colliding");
t->addEvent("input_missing");
t->addEvent("input_unexpected");
t->addEvent("timeout");
t->addEvent("wait_for_connected_input_port");
t->addEvent("wait_for_input");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("keep_position_on_exception", ConfigurationModel::BOOL);
	t->addProperty("nan_on_keep_position", ConfigurationModel::BOOL);
	t->addProperty("timeout_in", ConfigurationModel::DOUBLE);
	t->addProperty("timeout_cascade", ConfigurationModel::DOUBLE);
	t->addProperty("safe_mode", ConfigurationModel::BOOL);
}
{
auto t = new Task("Controldev::RawJoystickToMotion2D");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("minSpeed", ConfigurationModel::DOUBLE);
	t->addProperty("maxSpeed", ConfigurationModel::DOUBLE);
	t->addProperty("maxRotationSpeed", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Controldev::SliderboxTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("device", ConfigurationModel::STRING);
}
{
auto t = new Task("Controldev::SteeringWheelTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("Controldev::Mouse3DTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Controldev::Mouse3D");
t->addFullfillment("Base::RawCommandControllerSrv");
t->addFullfillment("Base::ControllerSrv");
}
{
auto t = new Task("Controldev::JoyPadTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("device", ConfigurationModel::STRING);
}
{
auto t = new Task("Hbridge::CommandWriter");
(void)t;
t->addEvent("bad_input");
t->addEvent("configuration_failed");
t->addEvent("error");
t->addEvent("io_error");
t->addEvent("mode_change_while_running");
t->addEvent("overheat_board");
t->addEvent("overheat_motor");
t->addEvent("over_current");
t->addEvent("protocol_error");
t->addEvent("sensor_failure");
t->addEvent("timeout");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Actuators::Hbridge");
t->addFullfillment("Dev::Bus::CAN::ClientSrv");
t->addFullfillment("Dev::Bus::CAN::ClientOutSrv");
t->addFullfillment("Dev::Bus::CAN::ClientInSrv");
	t->addProperty("comTimeout", ConfigurationModel::INT);
}
{
auto t = new Task("Controldev::JoystickTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Controldev::Joystick");
t->addFullfillment("Base::RawCommandControllerSrv");
t->addFullfillment("Base::ControllerSrv");
	t->addProperty("device", ConfigurationModel::STRING);
}
{
auto t = new Task("Controldev::GenericTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("RTT::TaskContext");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("AvalonControl::MotionFeedbackTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("config_value", ConfigurationModel::STRING);
}
{
auto t = new Task("Hbridge::SensorReader");
(void)t;
t->addEvent("bad_input");
t->addEvent("configuration_failed");
t->addEvent("io_error");
t->addEvent("protocol_error");
t->addEvent("sensor_failure");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::Hbridge");
t->addFullfillment("Base::JointsStatusSrv");
t->addFullfillment("Dev::Bus::CAN::ClientSrv");
t->addFullfillment("Dev::Bus::CAN::ClientOutSrv");
t->addFullfillment("Dev::Bus::CAN::ClientInSrv");
	t->addProperty("comTimeout", ConfigurationModel::INT);
	t->addProperty("isBusMaster", ConfigurationModel::INT);
}
{
auto t = new Task("WallServoing::DualSonarServoing");
(void)t;
t->addEvent("detected_corner");
t->addEvent("misconfiguration");
t->addEvent("searching_wall");
t->addEvent("wall_servoing");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("wall_distance", ConfigurationModel::DOUBLE);
	t->addProperty("fixed_depth", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_speed", ConfigurationModel::DOUBLE);
	t->addProperty("exploration_speed", ConfigurationModel::DOUBLE);
	t->addProperty("opening_angle", ConfigurationModel::DOUBLE);
	t->addProperty("enable_debug_output", ConfigurationModel::BOOL);
}
{
auto t = new Task("OrientationEstimator::BaseEstimator");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("aggregator_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("stream_aligner_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("imu_orientation_period", ConfigurationModel::DOUBLE);
	t->addProperty("fog_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("latitude", ConfigurationModel::DOUBLE);
	t->addProperty("longitude", ConfigurationModel::DOUBLE);
	t->addProperty("altitude", ConfigurationModel::DOUBLE);
	t->addProperty("magnetic_declination", ConfigurationModel::DOUBLE);
	t->addProperty("magnetic_declination_mode", ConfigurationModel::INT);
	t->addProperty("dip_angle", ConfigurationModel::DOUBLE);
	t->addProperty("use_initial_heading", ConfigurationModel::BOOL);
	t->addProperty("initial_heading", ConfigurationModel::DOUBLE);
	t->addProperty("substract_earth_rotation", ConfigurationModel::BOOL);
}
{
auto t = new Task("AvalonControl::TrajectoryFollower");
(void)t;
t->addEvent("align_at_end");
t->addEvent("cannot_find_closed_point");
t->addEvent("reached_end");
t->addEvent("waiting_for_pose");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::AUVRelativeMotionControllerSrv");
t->addFullfillment("Base::ControllerSrv");
t->addFullfillment("Base::WorldXYZRollPitchYawControllerSrv");
	t->addProperty("loop_spline", ConfigurationModel::BOOL);
	t->addProperty("deny_reverse", ConfigurationModel::BOOL);
	t->addProperty("use_zero_heading", ConfigurationModel::BOOL);
	t->addProperty("timeout_at_end_before_mark_end_reached", ConfigurationModel::DOUBLE);
	t->addProperty("final_heading", ConfigurationModel::DOUBLE);
	t->addProperty("step_width", ConfigurationModel::DOUBLE);
	t->addProperty("geometrical_resolution", ConfigurationModel::DOUBLE);
	t->addProperty("max_spline_jump_distance", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Buoy::Detector");
(void)t;
t->addEvent("buoy_found");
t->addEvent("no_buoy_found");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("buoy_radius", ConfigurationModel::DOUBLE);
	t->addProperty("hHoughAccumulatorThreshold", ConfigurationModel::INT);
	t->addProperty("sHoughAccumulatorThreshold", ConfigurationModel::INT);
	t->addProperty("vHoughAccumulatorThreshold", ConfigurationModel::INT);
	t->addProperty("hHoughEdgeThreshold", ConfigurationModel::INT);
	t->addProperty("sHoughEdgeThreshold", ConfigurationModel::INT);
	t->addProperty("vHoughEdgeThreshold", ConfigurationModel::INT);
	t->addProperty("houghMinCircle", ConfigurationModel::INT);
	t->addProperty("houghMaxCircle", ConfigurationModel::INT);
	t->addProperty("hValueMin", ConfigurationModel::INT);
	t->addProperty("sValueMin", ConfigurationModel::INT);
	t->addProperty("vValueMin", ConfigurationModel::INT);
	t->addProperty("hValueMax", ConfigurationModel::INT);
	t->addProperty("vValueMax", ConfigurationModel::INT);
	t->addProperty("sValueMax", ConfigurationModel::INT);
	t->addProperty("hSmooth", ConfigurationModel::INT);
	t->addProperty("sSmooth", ConfigurationModel::INT);
	t->addProperty("vSmooth", ConfigurationModel::INT);
	t->addProperty("debug_gui", ConfigurationModel::BOOL);
	t->addProperty("buoy_timeout", ConfigurationModel::INT);
	t->addProperty("filter_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("roi_x", ConfigurationModel::DOUBLE);
	t->addProperty("roi_y", ConfigurationModel::DOUBLE);
	t->addProperty("roi_width", ConfigurationModel::DOUBLE);
	t->addProperty("roi_height", ConfigurationModel::DOUBLE);
	t->addProperty("debug", ConfigurationModel::BOOL);
	t->addProperty("hsv_gray", ConfigurationModel::INT);
	t->addProperty("hough_debug_h", ConfigurationModel::BOOL);
	t->addProperty("hough_debug_s", ConfigurationModel::BOOL);
	t->addProperty("hough_debug_v", ConfigurationModel::BOOL);
	t->addProperty("use_h", ConfigurationModel::BOOL);
	t->addProperty("use_s", ConfigurationModel::BOOL);
	t->addProperty("use_v", ConfigurationModel::BOOL);
	t->addProperty("buoys_buffer_size", ConfigurationModel::INT);
	t->addProperty("buoys_buffer_size_min", ConfigurationModel::INT);
	t->addProperty("startvalidation", ConfigurationModel::INT);
	t->addProperty("mindist", ConfigurationModel::INT);
}
{
auto t = new Task("UwParticleLocalization::OrientationCorrection");
(void)t;
t->addEvent("reset");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("buffer_size", ConfigurationModel::INT);
	t->addProperty("min_buffer_size", ConfigurationModel::INT);
}
{
auto t = new Task("Buoy::Detector2");
(void)t;
t->addEvent("buoy_found");
t->addEvent("no_buoy_found");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("buoy_radius", ConfigurationModel::DOUBLE);
	t->addProperty("hHoughAccumulatorThreshold", ConfigurationModel::INT);
	t->addProperty("sHoughAccumulatorThreshold", ConfigurationModel::INT);
	t->addProperty("vHoughAccumulatorThreshold", ConfigurationModel::INT);
	t->addProperty("hHoughEdgeThreshold", ConfigurationModel::INT);
	t->addProperty("sHoughEdgeThreshold", ConfigurationModel::INT);
	t->addProperty("vHoughEdgeThreshold", ConfigurationModel::INT);
	t->addProperty("houghMinCircle", ConfigurationModel::INT);
	t->addProperty("houghMaxCircle", ConfigurationModel::INT);
	t->addProperty("hValueMin", ConfigurationModel::INT);
	t->addProperty("sValueMin", ConfigurationModel::INT);
	t->addProperty("vValueMin", ConfigurationModel::INT);
	t->addProperty("hValueMax", ConfigurationModel::INT);
	t->addProperty("vValueMax", ConfigurationModel::INT);
	t->addProperty("sValueMax", ConfigurationModel::INT);
	t->addProperty("hSmooth", ConfigurationModel::INT);
	t->addProperty("sSmooth", ConfigurationModel::INT);
	t->addProperty("vSmooth", ConfigurationModel::INT);
	t->addProperty("debug_gui", ConfigurationModel::BOOL);
	t->addProperty("buoy_timeout", ConfigurationModel::INT);
	t->addProperty("filter_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("roi_x", ConfigurationModel::DOUBLE);
	t->addProperty("roi_y", ConfigurationModel::DOUBLE);
	t->addProperty("roi_width", ConfigurationModel::DOUBLE);
	t->addProperty("roi_height", ConfigurationModel::DOUBLE);
	t->addProperty("debug", ConfigurationModel::BOOL);
	t->addProperty("hsv_gray", ConfigurationModel::INT);
	t->addProperty("hough_debug_h", ConfigurationModel::BOOL);
	t->addProperty("hough_debug_s", ConfigurationModel::BOOL);
	t->addProperty("hough_debug_v", ConfigurationModel::BOOL);
	t->addProperty("use_h", ConfigurationModel::BOOL);
	t->addProperty("use_s", ConfigurationModel::BOOL);
	t->addProperty("use_v", ConfigurationModel::BOOL);
	t->addProperty("buoys_buffer_size", ConfigurationModel::INT);
	t->addProperty("buoys_buffer_size_min", ConfigurationModel::INT);
	t->addProperty("startvalidation", ConfigurationModel::INT);
	t->addProperty("mindist", ConfigurationModel::INT);
}
{
auto t = new Task("StructureServoing::Task");
(void)t;
t->addEvent("no_orientation");
t->addEvent("no_structure");
t->addEvent("servoing");
t->addEvent("unsure");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("heading_speed", ConfigurationModel::DOUBLE);
	t->addProperty("strave_speed", ConfigurationModel::DOUBLE);
	t->addProperty("average_fill", ConfigurationModel::DOUBLE);
	t->addProperty("speed_factor", ConfigurationModel::DOUBLE);
	t->addProperty("lost_threashold", ConfigurationModel::DOUBLE);
	t->addProperty("lost_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("depth", ConfigurationModel::DOUBLE);
	t->addProperty("try_to_recover", ConfigurationModel::BOOL);
	t->addProperty("filter_factor", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Buoy::ServoingOnWall");
(void)t;
t->addEvent("aligned");
t->addEvent("buoy_servoing");
t->addEvent("passive_buoy_searching");
t->addEvent("wait_for_buoy_sample");
t->addEvent("wait_for_orientation_sample");
t->addEvent("wait_for_wall_sample");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("distance_to_buoy", ConfigurationModel::DOUBLE);
	t->addProperty("target_heading", ConfigurationModel::DOUBLE);
	t->addProperty("heading_step_size", ConfigurationModel::DOUBLE);
	t->addProperty("aligned_distance", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("WallServoing::SingleSonarServoing");
(void)t;
t->addEvent("alignment_complete");
t->addEvent("checking_wall");
t->addEvent("detected_corner");
t->addEvent("lost_wall");
t->addEvent("misconfiguration");
t->addEvent("origin_alignment");
t->addEvent("searching_wall");
t->addEvent("wall_servoing");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("wall_distance", ConfigurationModel::DOUBLE);
	t->addProperty("fixed_depth", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_speed", ConfigurationModel::DOUBLE);
	t->addProperty("exploration_speed", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_wall_direction", ConfigurationModel::DOUBLE);
	t->addProperty("initial_wall_direction", ConfigurationModel::DOUBLE);
	t->addProperty("minimal_wall_distance", ConfigurationModel::DOUBLE);
	t->addProperty("left_opening_angle", ConfigurationModel::DOUBLE);
	t->addProperty("right_opening_angle", ConfigurationModel::DOUBLE);
	t->addProperty("fading_out_factor", ConfigurationModel::DOUBLE);
	t->addProperty("wait_until_start", ConfigurationModel::DOUBLE);
	t->addProperty("use_motion_model", ConfigurationModel::BOOL);
	t->addProperty("check_distance_threshold", ConfigurationModel::DOUBLE);
	t->addProperty("use_front_distance", ConfigurationModel::BOOL);
	t->addProperty("left_front_angle", ConfigurationModel::DOUBLE);
	t->addProperty("right_front_angle", ConfigurationModel::DOUBLE);
	t->addProperty("enable_debug_output", ConfigurationModel::BOOL);
}
{
auto t = new Task("AvalonControl::RelFakeWriter");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::AUVRelativeMotionControllerSrv");
t->addFullfillment("Base::ControllerSrv");
	t->addProperty("x", ConfigurationModel::DOUBLE);
	t->addProperty("y", ConfigurationModel::DOUBLE);
	t->addProperty("z", ConfigurationModel::DOUBLE);
	t->addProperty("heading", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("StructureServoing::Alignment");
(void)t;
t->addEvent("aligned");
t->addEvent("aligning");
t->addEvent("no_structure");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("lost_threashold", ConfigurationModel::DOUBLE);
	t->addProperty("lost_timeout", ConfigurationModel::DOUBLE);
	t->addProperty("align_time", ConfigurationModel::DOUBLE);
	t->addProperty("align_threashold", ConfigurationModel::DOUBLE);
	t->addProperty("heading", ConfigurationModel::DOUBLE);
	t->addProperty("depth", ConfigurationModel::DOUBLE);
	t->addProperty("x_factor", ConfigurationModel::DOUBLE);
	t->addProperty("y_factor", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("AvalonControl::FakeWriter");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::AUVMotionControllerSrv");
t->addFullfillment("Base::ControllerSrv");
	t->addProperty("speed_x", ConfigurationModel::DOUBLE);
	t->addProperty("speed_y", ConfigurationModel::DOUBLE);
	t->addProperty("Z", ConfigurationModel::DOUBLE);
	t->addProperty("heading", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Syskit::ROS::Node");
(void)t;
t->addEvent("start");
t->addEvent("stop");
t->addEvent("interrupt");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("exception");
t->addEvent("fatal_error");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("AvalonControl::MotionControlTask");
(void)t;
t->addEvent("cutoff_vector_invalid");
t->addEvent("joint_names_invalid");
t->addEvent("timeout");
t->addEvent("waiting_for_command");
t->addEvent("waiting_for_orientation");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::AUVMotionControlledSystemSrv");
t->addFullfillment("Base::AUVMotionCommandConsumerSrv");
t->addFullfillment("Base::ControlledSystemSrv");
t->addFullfillment("Base::JointsControllerSrv");
t->addFullfillment("Base::ControllerSrv");
	t->addProperty("z_coupling_factor", ConfigurationModel::DOUBLE);
	t->addProperty("dagon_mode", ConfigurationModel::BOOL);
	t->addProperty("use_min_ground_distance", ConfigurationModel::BOOL);
	t->addProperty("min_ground_distance", ConfigurationModel::DOUBLE);
	t->addProperty("pitch_target", ConfigurationModel::DOUBLE);
	t->addProperty("y_factor", ConfigurationModel::DOUBLE);
	t->addProperty("y_coupling_factor", ConfigurationModel::DOUBLE);
	t->addProperty("x_factor", ConfigurationModel::DOUBLE);
	t->addProperty("timeout", ConfigurationModel::DOUBLE);
	t->addProperty("turn_coupling_factor", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Interfaces::IMU");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("imu_frame", ConfigurationModel::STRING);
	t->addProperty("world_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("LowLevelDriver::LowLevelTask");
(void)t;
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("longExposure", ConfigurationModel::INT);
	t->addProperty("shortExposure", ConfigurationModel::INT);
	t->addProperty("port", ConfigurationModel::STRING);
	t->addProperty("securityOverride", ConfigurationModel::BOOL);
}
{
auto t = new Task("Syskit::RubyTaskContext");
(void)t;
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("exception");
t->addEvent("fatal_error");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("Interfaces::LaserRangeFinder");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("remission_values", ConfigurationModel::BOOL);
	t->addProperty("start_step", ConfigurationModel::INT);
	t->addProperty("end_step", ConfigurationModel::INT);
	t->addProperty("scan_skip", ConfigurationModel::INT);
	t->addProperty("merge_count", ConfigurationModel::INT);
}
{
auto t = new Task("AvalonControl::PositionControlTask");
(void)t;
t->addEvent("position_variance_to_high");
t->addEvent("waiting_for_command");
t->addEvent("waiting_for_orientation");
t->addEvent("waiting_for_valid_orientation");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::AUVRelativeMotionControlledSystemSrv");
t->addFullfillment("Base::AUVRelativeMotionCommandConsumerSrv");
t->addFullfillment("Base::ControlledSystemSrv");
t->addFullfillment("Base::AUVMotionControllerSrv");
t->addFullfillment("Base::ControllerSrv");
	t->addProperty("timeout", ConfigurationModel::DOUBLE);
	t->addProperty("optimal_heading_distance", ConfigurationModel::DOUBLE);
	t->addProperty("position_variance_threshold", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Interfaces::ActuatorSensorReader");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("HsvMosaicing::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("cols", ConfigurationModel::INT);
	t->addProperty("rows", ConfigurationModel::INT);
	t->addProperty("averageFilled", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Interfaces::ActuatorCommandWriter");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("UwParticleLocalization::FastFusion");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("velocity_timeout", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Interfaces::Servo");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("zero_offset", ConfigurationModel::DOUBLE);
	t->addProperty("lower_sweep_angle", ConfigurationModel::DOUBLE);
	t->addProperty("upper_sweep_angle", ConfigurationModel::DOUBLE);
	t->addProperty("moving_speed", ConfigurationModel::DOUBLE);
	t->addProperty("upper_frame", ConfigurationModel::STRING);
	t->addProperty("lower_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("UwParticleLocalization::MotionModel");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("advanced_motion_model", ConfigurationModel::BOOL);
	t->addProperty("param_length", ConfigurationModel::DOUBLE);
	t->addProperty("param_radius", ConfigurationModel::DOUBLE);
	t->addProperty("param_mass", ConfigurationModel::DOUBLE);
	t->addProperty("param_thrusterVoltage", ConfigurationModel::DOUBLE);
	t->addProperty("param_floating", ConfigurationModel::BOOL);
	t->addProperty("aggregator_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("stream_aligner_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("thruster_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("orientation_samples_period", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("OrientationEstimator::IKF");
(void)t;
t->addEvent("alignment_error");
t->addEvent("configuration_error");
t->addEvent("initial_alignment");
t->addEvent("initial_north_seeking");
t->addEvent("missing_transformation");
t->addEvent("nan_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("initial_heading", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("imu_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("fog_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("initial_orientation_period", ConfigurationModel::DOUBLE);
	t->addProperty("imu_frame", ConfigurationModel::STRING);
	t->addProperty("body_frame", ConfigurationModel::STRING);
	t->addProperty("fog_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("AuvRelPosController::Task");
(void)t;
t->addEvent("invalid_position_command");
t->addEvent("timeout");
t->addEvent("waiting_for_position_command");
t->addEvent("waiting_for_valid_bodystate");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::AUVRelativeMotionControlledSystemSrv");
t->addFullfillment("Base::AUVRelativeMotionCommandConsumerSrv");
t->addFullfillment("Base::ControlledSystemSrv");
t->addFullfillment("Base::AUVMotionControllerSrv");
t->addFullfillment("Base::ControllerSrv");
	t->addProperty("timeout", ConfigurationModel::DOUBLE);
	t->addProperty("valid_timespan", ConfigurationModel::DOUBLE);
	t->addProperty("rel_z", ConfigurationModel::BOOL);
	t->addProperty("rel_heading", ConfigurationModel::BOOL);
}
{
auto t = new Task("OffshorePipelineDetector::SonarDetector");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("min_depth", ConfigurationModel::DOUBLE);
	t->addProperty("max_depth", ConfigurationModel::DOUBLE);
	t->addProperty("number_of_scans", ConfigurationModel::INT);
	t->addProperty("start_angle", ConfigurationModel::DOUBLE);
	t->addProperty("end_angle", ConfigurationModel::DOUBLE);
	t->addProperty("resolution", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("OffshorePipelineDetector::Task");
(void)t;
t->addEvent("align_auv");
t->addEvent("check_candidate");
t->addEvent("end_of_pipe");
t->addEvent("follow_pipe");
t->addEvent("found_pipe");
t->addEvent("lost_pipe");
t->addEvent("no_altitude_reading");
t->addEvent("no_orientation_reading");
t->addEvent("search_pipe");
t->addEvent("weak_signal");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("depth", ConfigurationModel::DOUBLE);
	t->addProperty("min_depth", ConfigurationModel::DOUBLE);
	t->addProperty("max_depth", ConfigurationModel::DOUBLE);
	t->addProperty("distance_to_pipe", ConfigurationModel::DOUBLE);
	t->addProperty("prefered_heading", ConfigurationModel::DOUBLE);
	t->addProperty("end_of_pipe_offset", ConfigurationModel::DOUBLE);
	t->addProperty("delta_aligning", ConfigurationModel::DOUBLE);
	t->addProperty("max_center_dist", ConfigurationModel::DOUBLE);
	t->addProperty("min_center_dist", ConfigurationModel::DOUBLE);
	t->addProperty("do_dynamic_aligning", ConfigurationModel::BOOL);
	t->addProperty("preffered_turn_direction", ConfigurationModel::INT);
	t->addProperty("max_align_turn_speed_per_s", ConfigurationModel::DOUBLE);
	t->addProperty("time_between_detection", ConfigurationModel::DOUBLE);
	t->addProperty("maximum_check_time", ConfigurationModel::DOUBLE);
	t->addProperty("align_during_check", ConfigurationModel::BOOL);
	t->addProperty("default_x", ConfigurationModel::DOUBLE);
	t->addProperty("weak_signal_x", ConfigurationModel::DOUBLE);
	t->addProperty("default_distance_to_pipe", ConfigurationModel::DOUBLE);
	t->addProperty("default_fx", ConfigurationModel::DOUBLE);
	t->addProperty("default_fy", ConfigurationModel::DOUBLE);
	t->addProperty("search_depth_delta", ConfigurationModel::DOUBLE);
	t->addProperty("out_of_center", ConfigurationModel::DOUBLE);
	t->addProperty("min_count", ConfigurationModel::INT);
	t->addProperty("min_width", ConfigurationModel::DOUBLE);
	t->addProperty("max_width", ConfigurationModel::DOUBLE);
	t->addProperty("find_confidence", ConfigurationModel::DOUBLE);
	t->addProperty("lose_confidence", ConfigurationModel::DOUBLE);
	t->addProperty("find_anisotropy", ConfigurationModel::DOUBLE);
	t->addProperty("find_end_of_pipe", ConfigurationModel::DOUBLE);
	t->addProperty("lose_end_of_pipe", ConfigurationModel::DOUBLE);
	t->addProperty("weak_signal", ConfigurationModel::DOUBLE);
	t->addProperty("min_heading", ConfigurationModel::DOUBLE);
	t->addProperty("max_heading", ConfigurationModel::DOUBLE);
	t->addProperty("invert_colors", ConfigurationModel::BOOL);
	t->addProperty("use_channel", ConfigurationModel::INT);
	t->addProperty("debugging", ConfigurationModel::BOOL);
	t->addProperty("preprocessing_type", ConfigurationModel::INT);
}
{
auto t = new Task("Gps::MB500Task");
(void)t;
t->addEvent("io_error");
t->addEvent("io_timeout");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::GPS");
t->addFullfillment("Base::PositionSrv");
	t->addProperty("utm_zone", ConfigurationModel::INT);
	t->addProperty("utm_north", ConfigurationModel::BOOL);
	t->addProperty("device", ConfigurationModel::STRING);
	t->addProperty("port", ConfigurationModel::STRING);
	t->addProperty("correction_port", ConfigurationModel::STRING);
	t->addProperty("period", ConfigurationModel::DOUBLE);
	t->addProperty("ntpd_shm_unit", ConfigurationModel::INT);
}
{
auto t = new Task("Gps::GPSDTask");
(void)t;
t->addEvent("io_error");
t->addEvent("io_timeout");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::GPS");
t->addFullfillment("Base::PositionSrv");
	t->addProperty("utm_zone", ConfigurationModel::INT);
	t->addProperty("utm_north", ConfigurationModel::BOOL);
	t->addProperty("hostname", ConfigurationModel::STRING);
}
{
auto t = new Task("Taskmon::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("watch_all", ConfigurationModel::BOOL);
}
{
auto t = new Task("Gps::BaseTask");
(void)t;
t->addEvent("io_error");
t->addEvent("io_timeout");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::GPS");
t->addFullfillment("Base::PositionSrv");
	t->addProperty("utm_zone", ConfigurationModel::INT);
	t->addProperty("utm_north", ConfigurationModel::BOOL);
}
{
auto t = new Task("LineScanner::Task");
(void)t;
t->addEvent("empty_image");
t->addEvent("no_laser");
t->addEvent("overexposed");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("debug_mode", ConfigurationModel::BOOL);
	t->addProperty("use_green_channel", ConfigurationModel::BOOL);
	t->addProperty("unique_solution", ConfigurationModel::BOOL);
	t->addProperty("undistort_frame", ConfigurationModel::BOOL);
	t->addProperty("subpixel", ConfigurationModel::BOOL);
	t->addProperty("laser_width_top", ConfigurationModel::DOUBLE);
	t->addProperty("laser_width_bottom", ConfigurationModel::DOUBLE);
	t->addProperty("min_segment_length", ConfigurationModel::INT);
	t->addProperty("min_snr", ConfigurationModel::DOUBLE);
	t->addProperty("max_gap_length", ConfigurationModel::DOUBLE);
	t->addProperty("min_seperation", ConfigurationModel::INT);
	t->addProperty("col_step", ConfigurationModel::INT);
	t->addProperty("colorize_points", ConfigurationModel::BOOL);
	t->addProperty("colorize_interval", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Sysmon::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::SystemStatus");
t->addFullfillment("Dev::Bus::CAN::ClientInSrv");
}
{
auto t = new Task("Modemdriver::Modem");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("distance_request_interval", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("Modemdriver::ModemSerial");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("distance_request_interval", ConfigurationModel::DOUBLE);
	t->addProperty("serial_device", ConfigurationModel::STRING);
}
{
auto t = new Task("Modemdriver::ModemCanbus");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::ASVModem");
t->addFullfillment("Dev::Bus::CAN::ClientOutSrv");
	t->addProperty("distance_request_interval", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("SonarStructureServoing::Task");
(void)t;
t->addEvent("inspecting_structure");
t->addEvent("missing_transformation");
t->addEvent("searching_structure");
t->addEvent("validating_structure");
t->addEvent("waiting_for_target_depth");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("servoing_direction", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_distance", ConfigurationModel::DOUBLE);
	t->addProperty("fixed_depth", ConfigurationModel::DOUBLE);
	t->addProperty("servoing_speed", ConfigurationModel::DOUBLE);
	t->addProperty("left_opening_angle", ConfigurationModel::DOUBLE);
	t->addProperty("right_opening_angle", ConfigurationModel::DOUBLE);
	t->addProperty("angular_resolution_sonar", ConfigurationModel::DOUBLE);
	t->addProperty("dbscan_epsilon", ConfigurationModel::DOUBLE);
	t->addProperty("expected_structure_diameter", ConfigurationModel::DOUBLE);
	t->addProperty("max_mahalanobis_distance", ConfigurationModel::DOUBLE);
	t->addProperty("min_valid_cadidate_count", ConfigurationModel::INT);
	t->addProperty("enable_debug", ConfigurationModel::BOOL);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("odometry_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("sonarbeam_feature_period", ConfigurationModel::DOUBLE);
	t->addProperty("sonar_frame", ConfigurationModel::STRING);
	t->addProperty("body_frame", ConfigurationModel::STRING);
	t->addProperty("odometry_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("ModemCan::Task");
(void)t;
t->addEvent("controlling");
t->addEvent("sended_command");
t->addEvent("waiting_for_input");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::Modem");
t->addFullfillment("Dev::Bus::CAN::ClientInSrv");
	t->addProperty("scale", ConfigurationModel::DOUBLE);
	t->addProperty("sendInterval", ConfigurationModel::DOUBLE);
	t->addProperty("resend_time", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("GpsHelper::MapToGPS");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("utm_zone", ConfigurationModel::INT);
	t->addProperty("utm_north", ConfigurationModel::BOOL);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("position_samples_period", ConfigurationModel::DOUBLE);
	t->addProperty("map_frame", ConfigurationModel::STRING);
	t->addProperty("gps_utm_zone_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("ImagePreprocessing::BaseTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("calibrate", ConfigurationModel::BOOL);
	t->addProperty("scale_x", ConfigurationModel::DOUBLE);
	t->addProperty("scale_y", ConfigurationModel::DOUBLE);
	t->addProperty("offset_x", ConfigurationModel::INT);
	t->addProperty("offset_y", ConfigurationModel::INT);
}
{
auto t = new Task("BatteryWatcher::Task");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::Battery");
t->addFullfillment("Dev::Bus::CAN::ClientInSrv");
}
{
auto t = new Task("ImagePreprocessing::DepthImage2Pointcloud");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("aggregator_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("stream_aligner_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("color_frame_period", ConfigurationModel::DOUBLE);
	t->addProperty("frame_period", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("input_frame", ConfigurationModel::STRING);
	t->addProperty("pc_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("ImagePreprocessing::MonoTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("calibrate", ConfigurationModel::BOOL);
	t->addProperty("scale_x", ConfigurationModel::DOUBLE);
	t->addProperty("scale_y", ConfigurationModel::DOUBLE);
	t->addProperty("offset_x", ConfigurationModel::INT);
	t->addProperty("offset_y", ConfigurationModel::INT);
}
{
auto t = new Task("ImagePreprocessing::HSVSegmentationAndBlur");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("hMin", ConfigurationModel::INT);
	t->addProperty("hMax", ConfigurationModel::INT);
	t->addProperty("vMin", ConfigurationModel::INT);
	t->addProperty("sMax", ConfigurationModel::INT);
	t->addProperty("sMin", ConfigurationModel::INT);
	t->addProperty("vMax", ConfigurationModel::INT);
	t->addProperty("blur", ConfigurationModel::INT);
	t->addProperty("unsetValue", ConfigurationModel::INT);
	t->addProperty("invert", ConfigurationModel::BOOL);
	t->addProperty("minVadapt", ConfigurationModel::INT);
	t->addProperty("maxVadapt", ConfigurationModel::INT);
	t->addProperty("target_pixel_s", ConfigurationModel::INT);
	t->addProperty("steps_per_frame", ConfigurationModel::INT);
}
{
auto t = new Task("StructureReconstruction::Task");
(void)t;
t->addEvent("missing_transformation");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("target_folder", ConfigurationModel::STRING);
	t->addProperty("time_delta", ConfigurationModel::DOUBLE);
	t->addProperty("translation_delta", ConfigurationModel::DOUBLE);
	t->addProperty("rotation_delta", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_max_latency", ConfigurationModel::DOUBLE);
	t->addProperty("transformer_status_period", ConfigurationModel::DOUBLE);
	t->addProperty("front_camera_period", ConfigurationModel::DOUBLE);
	t->addProperty("bottom_camera_period", ConfigurationModel::DOUBLE);
	t->addProperty("front_camera_frame", ConfigurationModel::STRING);
	t->addProperty("body_frame", ConfigurationModel::STRING);
	t->addProperty("bottom_camera_frame", ConfigurationModel::STRING);
	t->addProperty("world_frame", ConfigurationModel::STRING);
}
{
auto t = new Task("ImagePreprocessing::StereoTask");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("calibrate", ConfigurationModel::BOOL);
	t->addProperty("scale_x", ConfigurationModel::DOUBLE);
	t->addProperty("scale_y", ConfigurationModel::DOUBLE);
	t->addProperty("offset_x", ConfigurationModel::INT);
	t->addProperty("offset_y", ConfigurationModel::INT);
}
{
auto t = new Task("GpsHelper::WaypointNavigation");
(void)t;
t->addEvent("last_waypoint_reached");
t->addEvent("validating_gps_fix");
t->addEvent("waiting_for_gps_fix");
t->addEvent("waypoint_reached");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("valid_gps_fix_time", ConfigurationModel::DOUBLE);
	t->addProperty("min_distance_delta", ConfigurationModel::DOUBLE);
	t->addProperty("waypoint_radius", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("GpsHelper::GPSFaker");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("write_valid_samples", ConfigurationModel::BOOL);
}
{
auto t = new Task("VideoStreamerVlc::Streamer{1}");
(void)t;
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::ImageConsumerSrv");
t->addFullfillment("Base::ImageConsumerSrv");
t->addFullfillment("Base::ImageConsumerSrv");
}
{
auto t = new Task("VideoStreamerVlc::Capturer");
(void)t;
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
}
{
auto t = new Task("VideoStreamerVlc::Streamer");
(void)t;
t->addEvent("io_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::ImageConsumerSrv");
t->addFullfillment("Base::ImageConsumerSrv");
t->addFullfillment("Base::ImageConsumerSrv");
}
{
auto t = new Task("AuvWaypointNavigator::Task");
(void)t;
t->addEvent("dynamic_navigation");
t->addEvent("keep_waypoint");
t->addEvent("no_pose_samples");
t->addEvent("static_navigation");
t->addEvent("wait_for_waypoints");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("timeout", ConfigurationModel::DOUBLE);
	t->addProperty("z_tolerance", ConfigurationModel::DOUBLE);
	t->addProperty("z_init", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("RearSonarDistanceEstimator::Task");
(void)t;
t->addEvent("timeout_depth");
t->addEvent("timeout_sonar");
t->addEvent("waiting_for_depth");
t->addEvent("waiting_for_sonar");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("sonar_timeout", ConfigurationModel::INT);
	t->addProperty("depth_timeout", ConfigurationModel::INT);
}
{
auto t = new Task("Lights::Lights");
(void)t;
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Actuators::Lights");
t->addFullfillment("Dev::Bus::CAN::ClientInSrv");
	t->addProperty("device", ConfigurationModel::STRING);
	t->addProperty("using_can", ConfigurationModel::BOOL);
}
{
auto t = new Task("CameraProsilica::Task");
(void)t;
t->addEvent("cannot_start_grabbing");
t->addEvent("configure_error");
t->addEvent("no_camera");
t->addEvent("no_camera_interface");
t->addEvent("processing_error");
t->addEvent("unkown_parameter");
t->addEvent("unsupported_parameter");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Dev::Sensors::Cameras::Prosilica");
t->addFullfillment("Base::ImageProviderSrv");
	t->addProperty("camera_id", ConfigurationModel::STRING);
	t->addProperty("width", ConfigurationModel::INT);
	t->addProperty("height", ConfigurationModel::INT);
	t->addProperty("fps", ConfigurationModel::DOUBLE);
	t->addProperty("frame_buffer_size", ConfigurationModel::INT);
	t->addProperty("clear_buffer_if_frame_drop", ConfigurationModel::BOOL);
	t->addProperty("disable_frame_raw", ConfigurationModel::BOOL);
	t->addProperty("log_interval_in_sec", ConfigurationModel::INT);
	t->addProperty("region_x", ConfigurationModel::INT);
	t->addProperty("region_y", ConfigurationModel::INT);
	t->addProperty("trigger_mode", ConfigurationModel::STRING);
	t->addProperty("channel_data_depth", ConfigurationModel::INT);
	t->addProperty("exposure", ConfigurationModel::INT);
	t->addProperty("exposure_mode", ConfigurationModel::STRING);
	t->addProperty("gain_mode_auto", ConfigurationModel::BOOL);
	t->addProperty("gain", ConfigurationModel::INT);
	t->addProperty("gamma", ConfigurationModel::BOOL);
	t->addProperty("acquisition_frame_count", ConfigurationModel::INT);
	t->addProperty("binning_x", ConfigurationModel::INT);
	t->addProperty("binning_y", ConfigurationModel::INT);
	t->addProperty("mode", ConfigurationModel::STRING);
	t->addProperty("synchronize_time_interval", ConfigurationModel::INT);
	t->addProperty("whitebalance_mode", ConfigurationModel::STRING);
	t->addProperty("whitebalance_blue", ConfigurationModel::INT);
	t->addProperty("whitebalance_red", ConfigurationModel::INT);
	t->addProperty("whitebalance_auto_rate", ConfigurationModel::INT);
	t->addProperty("whitebalance_auto_threshold", ConfigurationModel::INT);
	t->addProperty("frame_start_trigger_event", ConfigurationModel::STRING);
	t->addProperty("package_size", ConfigurationModel::INT);
	t->addProperty("sync_out1_mode", ConfigurationModel::STRING);
	t->addProperty("sync_out2_mode", ConfigurationModel::STRING);
	t->addProperty("undistort", ConfigurationModel::BOOL);
	t->addProperty("scale_x", ConfigurationModel::DOUBLE);
	t->addProperty("scale_y", ConfigurationModel::DOUBLE);
	t->addProperty("offset_x", ConfigurationModel::INT);
	t->addProperty("offset_y", ConfigurationModel::INT);
	t->addProperty("camera_ip", ConfigurationModel::STRING);
}
{
auto t = new Task("CameraBase::Task");
(void)t;
t->addEvent("cannot_start_grabbing");
t->addEvent("configure_error");
t->addEvent("no_camera");
t->addEvent("no_camera_interface");
t->addEvent("processing_error");
t->addEvent("unkown_parameter");
t->addEvent("unsupported_parameter");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("camera_id", ConfigurationModel::STRING);
	t->addProperty("width", ConfigurationModel::INT);
	t->addProperty("height", ConfigurationModel::INT);
	t->addProperty("fps", ConfigurationModel::DOUBLE);
	t->addProperty("frame_buffer_size", ConfigurationModel::INT);
	t->addProperty("clear_buffer_if_frame_drop", ConfigurationModel::BOOL);
	t->addProperty("disable_frame_raw", ConfigurationModel::BOOL);
	t->addProperty("log_interval_in_sec", ConfigurationModel::INT);
	t->addProperty("region_x", ConfigurationModel::INT);
	t->addProperty("region_y", ConfigurationModel::INT);
	t->addProperty("trigger_mode", ConfigurationModel::STRING);
	t->addProperty("channel_data_depth", ConfigurationModel::INT);
	t->addProperty("exposure", ConfigurationModel::INT);
	t->addProperty("exposure_mode", ConfigurationModel::STRING);
	t->addProperty("gain_mode_auto", ConfigurationModel::BOOL);
	t->addProperty("gain", ConfigurationModel::INT);
	t->addProperty("gamma", ConfigurationModel::BOOL);
	t->addProperty("acquisition_frame_count", ConfigurationModel::INT);
	t->addProperty("binning_x", ConfigurationModel::INT);
	t->addProperty("binning_y", ConfigurationModel::INT);
	t->addProperty("mode", ConfigurationModel::STRING);
	t->addProperty("synchronize_time_interval", ConfigurationModel::INT);
	t->addProperty("whitebalance_mode", ConfigurationModel::STRING);
	t->addProperty("whitebalance_blue", ConfigurationModel::INT);
	t->addProperty("whitebalance_red", ConfigurationModel::INT);
	t->addProperty("whitebalance_auto_rate", ConfigurationModel::INT);
	t->addProperty("whitebalance_auto_threshold", ConfigurationModel::INT);
	t->addProperty("frame_start_trigger_event", ConfigurationModel::STRING);
	t->addProperty("package_size", ConfigurationModel::INT);
	t->addProperty("sync_out1_mode", ConfigurationModel::STRING);
	t->addProperty("sync_out2_mode", ConfigurationModel::STRING);
	t->addProperty("undistort", ConfigurationModel::BOOL);
	t->addProperty("scale_x", ConfigurationModel::DOUBLE);
	t->addProperty("scale_y", ConfigurationModel::DOUBLE);
	t->addProperty("offset_x", ConfigurationModel::INT);
	t->addProperty("offset_y", ConfigurationModel::INT);
}
{
auto t = new Task("AvalonControl::MotionControlTask<Base::AUVMotionControllerSrv>");
(void)t;
t->addEvent("cutoff_vector_invalid");
t->addEvent("joint_names_invalid");
t->addEvent("timeout");
t->addEvent("waiting_for_command");
t->addEvent("waiting_for_orientation");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
t->addFullfillment("Base::AUVMotionControllerSrv");
t->addFullfillment("Base::ControllerSrv");
t->addFullfillment("Base::AUVMotionControlledSystemSrv");
t->addFullfillment("Base::AUVMotionCommandConsumerSrv");
t->addFullfillment("Base::ControlledSystemSrv");
t->addFullfillment("Base::JointsControllerSrv");
t->addFullfillment("Base::ControllerSrv");
	t->addProperty("z_coupling_factor", ConfigurationModel::DOUBLE);
	t->addProperty("dagon_mode", ConfigurationModel::BOOL);
	t->addProperty("use_min_ground_distance", ConfigurationModel::BOOL);
	t->addProperty("min_ground_distance", ConfigurationModel::DOUBLE);
	t->addProperty("pitch_target", ConfigurationModel::DOUBLE);
	t->addProperty("y_factor", ConfigurationModel::DOUBLE);
	t->addProperty("y_coupling_factor", ConfigurationModel::DOUBLE);
	t->addProperty("x_factor", ConfigurationModel::DOUBLE);
	t->addProperty("timeout", ConfigurationModel::DOUBLE);
	t->addProperty("turn_coupling_factor", ConfigurationModel::DOUBLE);
}
{
auto t = new Task("CameraBase::Preprocess");
(void)t;
t->addEvent("processing_error");
t->addEvent("init");
t->addEvent("pre_operational");
t->addEvent("fatal_error");
t->addEvent("exception");
t->addEvent("stopped");
t->addEvent("running");
t->addEvent("runtime_error");
t->addEvent("start");
t->addEvent("interrupt");
t->addEvent("stop");
t->addEvent("failed");
t->addEvent("success");
t->addEvent("aborted");
t->addEvent("internal_error");
t->addEvent("updated_data");
t->addEvent("poll_transition");
	t->addProperty("undistort", ConfigurationModel::BOOL);
	t->addProperty("scale_x", ConfigurationModel::DOUBLE);
	t->addProperty("scale_y", ConfigurationModel::DOUBLE);
	t->addProperty("offset_x", ConfigurationModel::INT);
	t->addProperty("offset_y", ConfigurationModel::INT);
}
{
auto c = new Composition("Localization::ParticleDetector");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("UwParticleLocalization::Task"),"main");
c->addChild(pool->getComponent("Base::SonarScanProviderSrv"),"sonar");
c->addChild(pool->getComponent("SonarFeatureEstimator::Task"),"sonar_estimator");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"ori");
c->addChild(pool->getComponent("Base::JointsStatusSrv"),"hb");
c->addFullfillment("Localization::ParticleDetector");
c->addFullfillment("Base::VelocitySrv");
c->addFullfillment("Base::PoseSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
c->addFullfillment("Base::MapSrv");
c->addFullfillment("Base::VelocitySrv");
c->addFullfillment("Base::PoseSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
c->addFullfillment("Base::MapSrv");
}
{
auto c = new Composition("PoseAuv::PoseEstimatorCmp");
c->addEvent("MISSING_TRANSFORMATION");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("reset", ConfigurationModel::BOOL);
c->addChild(pool->getComponent("PoseEstimation::UWPoseEstimator"),"pose_estimator");
c->addChild(pool->getComponent("Base::OrientationSrv"),"ori");
c->addChild(pool->getComponent("Base::VelocitySrv"),"model");
c->addChild(pool->getComponent("Base::ZProviderSrv"),"depth");
c->addFullfillment("PoseAuv::PoseEstimatorCmp");
c->addFullfillment("Base::PoseSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
c->addFullfillment("Base::PoseSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
}
{
auto c = new Composition("PoseAuv::PoseEstimatorBlindCmp");
c->addEvent("MISSING_TRANSFORMATION");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("reset", ConfigurationModel::BOOL);
c->addChild(pool->getComponent("PoseEstimation::UWPoseEstimator"),"pose_estimator");
c->addChild(pool->getComponent("Base::OrientationSrv"),"ori");
c->addChild(pool->getComponent("Base::VelocitySrv"),"model");
c->addChild(pool->getComponent("Base::ZProviderSrv"),"depth");
c->addFullfillment("PoseAuv::PoseEstimatorBlindCmp");
c->addFullfillment("Base::PoseSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
c->addFullfillment("Base::PoseSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::PositionSrv");
}
{
auto c = new Composition("AuvControl::MotionControlCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("AvalonControl::MotionControlTask"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"pose");
c->addChild(pool->getComponent("Base::GroundDistanceSrv"),"dist");
c->addFullfillment("AuvControl::MotionControlCmp");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("Buoy::DetectorCmp2");
c->addEvent("buoy_search");
c->addEvent("buoy_detected");
c->addEvent("buoy_arrived");
c->addEvent("buoy_lost");
c->addEvent("strafing");
c->addEvent("strafe_finished");
c->addEvent("strafe_to_angle");
c->addEvent("angle_arrived");
c->addEvent("timeout");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"camera");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addChild(pool->getComponent("Buoy::Detector2"),"detector");
c->addFullfillment("Buoy::DetectorCmp2");
}
{
auto c = new Composition("Pipeline::Detector_new");
c->addEvent("check_candidate");
c->addEvent("follow_pipe");
c->addEvent("found_pipe");
c->addEvent("align_auv");
c->addEvent("lost_pipe");
c->addEvent("search_pipe");
c->addEvent("end_of_pipe");
c->addEvent("weak_signal");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("depth", ConfigurationModel::DOUBLE);
	c->addProperty("heading", ConfigurationModel::DOUBLE);
	c->addProperty("speed_x", ConfigurationModel::DOUBLE);
	c->addProperty("turn_dir", ConfigurationModel::INT);
c->addChild(pool->getComponent("OffshorePipelineDetector::Task"),"offshorePipelineDetector");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"camera");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addFullfillment("Pipeline::Detector_new");
c->addFullfillment("Base::WorldXYPositionControllerSrv");
c->addFullfillment("Base::WorldXYPositionControllerSrv");
}
{
auto c = new Composition("Buoy::DetectorCmp");
c->addEvent("buoy_search");
c->addEvent("buoy_detected");
c->addEvent("buoy_arrived");
c->addEvent("buoy_lost");
c->addEvent("strafing");
c->addEvent("strafe_finished");
c->addEvent("strafe_to_angle");
c->addEvent("angle_arrived");
c->addEvent("timeout");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"camera");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addChild(pool->getComponent("Buoy::Detector"),"detector");
c->addFullfillment("Buoy::DetectorCmp");
}
{
auto c = new Composition("PoseAuv::IKFOrientationEstimatorCmp");
c->addEvent("INITIAL_NORTH_SEEKING");
c->addEvent("INITIAL_ALIGNMENT");
c->addEvent("MISSING_TRANSFORMATION");
c->addEvent("NAN_ERROR");
c->addEvent("ALIGNMENT_ERROR");
c->addEvent("CONFIGURATION_ERROR");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("OrientationEstimator::BaseEstimator"),"estimator");
c->addChild(pool->getComponent("WallOrientationCorrection::OrientationInMap"),"ori_in_map");
c->addChild(pool->getComponent("XsensImu::Task"),"imu");
c->addChild(pool->getComponent("FogKvh::Dsp3000Task"),"fog");
c->addFullfillment("PoseAuv::IKFOrientationEstimatorCmp");
c->addFullfillment("Base::OrientationToCorrectSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::OrientationToCorrectSrv");
c->addFullfillment("Base::OrientationSrv");
}
{
auto c = new Composition("Pipeline::Detector");
c->addEvent("check_candidate");
c->addEvent("follow_pipe");
c->addEvent("found_pipe");
c->addEvent("align_auv");
c->addEvent("lost_pipe");
c->addEvent("search_pipe");
c->addEvent("end_of_pipe");
c->addEvent("weak_signal");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("depth", ConfigurationModel::DOUBLE);
	c->addProperty("heading", ConfigurationModel::DOUBLE);
	c->addProperty("speed_x", ConfigurationModel::DOUBLE);
	c->addProperty("turn_dir", ConfigurationModel::INT);
c->addChild(pool->getComponent("OffshorePipelineDetector::Task"),"offshorePipelineDetector");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"camera");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addFullfillment("Pipeline::Detector");
c->addFullfillment("Base::AUVRelativeMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::AUVRelativeMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::ControllerSrv");
}
{
auto c = new Composition("Buoy::DetectorNewCmp");
c->addEvent("buoy_found");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Buoy::Detector"),"main");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"front_camera");
c->addFullfillment("Buoy::DetectorNewCmp");
}
{
auto c = new Composition("Pipeline::Follower");
c->addEvent("check_candidate");
c->addEvent("follow_pipe");
c->addEvent("found_pipe");
c->addEvent("align_auv");
c->addEvent("lost_pipe");
c->addEvent("search_pipe");
c->addEvent("end_of_pipe");
c->addEvent("weak_signal");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("depth", ConfigurationModel::DOUBLE);
	c->addProperty("heading", ConfigurationModel::DOUBLE);
	c->addProperty("speed_x", ConfigurationModel::DOUBLE);
	c->addProperty("turn_dir", ConfigurationModel::INT);
c->addChild(pool->getComponent("Pipeline::Detector"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("Pipeline::Detector"),"controller_local");
c->addFullfillment("Pipeline::Follower");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("AuvControl::RelPosControlCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("AuvRelPosController::Task"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addFullfillment("AuvControl::RelPosControlCmp");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("ConsWA");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("AuvControl::ConstantCommand"),"controller_v");
c->addFullfillment("ConsWA");
}
{
auto c = new Composition("AuvControl::PositionControlCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("AvalonControl::PositionControlTask"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addFullfillment("AuvControl::PositionControlCmp");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("Wall::DetectorNew");
c->addEvent("wall_servoing");
c->addEvent("searching_wall");
c->addEvent("checking_wall");
c->addEvent("detected_corner");
c->addEvent("lost_all");
c->addEvent("origin_alignment");
c->addEvent("alignment_complete");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("max_corners", ConfigurationModel::INT);
c->addChild(pool->getComponent("WallServoing::SingleSonarServoing"),"detector");
c->addChild(pool->getComponent("SonarTritech::Micron"),"sonar");
c->addChild(pool->getComponent("SonarFeatureEstimator::Task"),"sonar_estimator");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addFullfillment("Wall::DetectorNew");
c->addFullfillment("WallServoing::WallOrientationSrv");
c->addFullfillment("Base::WorldXYPositionControllerSrv");
c->addFullfillment("WallServoing::WallOrientationSrv");
c->addFullfillment("Base::WorldXYPositionControllerSrv");
}
{
auto c = new Composition("Wall::Detector");
c->addEvent("wall_servoing");
c->addEvent("searching_wall");
c->addEvent("checking_wall");
c->addEvent("detected_corner");
c->addEvent("lost_all");
c->addEvent("origin_alignment");
c->addEvent("alignment_complete");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("WallServoing::SingleSonarServoing"),"detector");
c->addChild(pool->getComponent("SonarTritech::Micron"),"sonar");
c->addChild(pool->getComponent("SonarFeatureEstimator::Task"),"sonar_estimator");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addFullfillment("Wall::Detector");
c->addFullfillment("Base::AUVRelativeMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::AUVRelativeMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::ControllerSrv");
}
{
auto c = new Composition("Hbridge::ControlSystem");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Dev::Sensors::Hbridge"),"sensors");
c->addChild(pool->getComponent("Dev::Actuators::Hbridge"),"command");
c->addFullfillment("Hbridge::ControlSystem");
c->addFullfillment("Base::JointsControlledSystemSrv");
c->addFullfillment("Base::JointsStatusSrv");
c->addFullfillment("Base::JointsCommandConsumerSrv");
c->addFullfillment("Base::ControlledSystemSrv");
c->addFullfillment("Base::JointsControlledSystemSrv");
c->addFullfillment("Base::JointsStatusSrv");
c->addFullfillment("Base::JointsCommandConsumerSrv");
c->addFullfillment("Base::ControlledSystemSrv");
c->addFullfillment("Base::JointsStatusSrv");
c->addFullfillment("Base::JointsCommandConsumerSrv");
c->addFullfillment("Base::ControlledSystemSrv");
}
{
auto c = new Composition("AuvControl::TrajectoryMove");
c->addEvent("reached_end");
c->addEvent("align_at_end");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("event_on_timeout", ConfigurationModel::STRING);
c->addChild(pool->getComponent("AvalonControl::TrajectoryFollower"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("AvalonControl::TrajectoryFollower"),"foo");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addFullfillment("AuvControl::TrajectoryMove");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("AuvControl::SimpleMove");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("depth", ConfigurationModel::DOUBLE);
	c->addProperty("heading", ConfigurationModel::DOUBLE);
	c->addProperty("delta_timeout", ConfigurationModel::DOUBLE);
	c->addProperty("speed_x", ConfigurationModel::DOUBLE);
	c->addProperty("speed_y", ConfigurationModel::DOUBLE);
	c->addProperty("finish_when_reached", ConfigurationModel::BOOL);
	c->addProperty("event_on_timeout", ConfigurationModel::STRING);
	c->addProperty("delta_z", ConfigurationModel::DOUBLE);
	c->addProperty("delta_yaw", ConfigurationModel::DOUBLE);
c->addChild(pool->getComponent("AvalonControl::FakeWriter"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"reading");
c->addArgumentForwards("controller", "heading", "heading");
c->addArgumentForwards("controller", "depth", "depth");
c->addArgumentForwards("controller", "speed_x", "speed_x");
c->addArgumentForwards("controller", "speed_y", "speed_y");
c->addFullfillment("AuvControl::SimpleMove");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("AuvControl::DepthFusionCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::ZProviderSrv"),"z");
c->addChild(pool->getComponent("Base::OrientationSrv"),"ori");
c->addChild(pool->getComponent("AuvHelper::DepthAndOrientationFusion"),"task");
c->addFullfillment("AuvControl::DepthFusionCmp");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::OrientationWithZSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
c->addFullfillment("Base::ZProviderSrv");
c->addFullfillment("Base::OrientationSrv");
}
{
auto c = new Composition("Localization::HoughDetector");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("SonarWallHough::Task"),"main");
c->addChild(pool->getComponent("Base::SonarScanProviderSrv"),"sonar");
c->addChild(pool->getComponent("Base::OrientationSrv"),"ori");
c->addFullfillment("Localization::HoughDetector");
c->addFullfillment("Localization::HoughSrv");
c->addFullfillment("Localization::HoughSrv");
}
{
auto c = new Composition("Localization::DeadReckoning");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("UwParticleLocalization::MotionModel"),"main");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"ori");
c->addChild(pool->getComponent("Base::JointsStatusSrv"),"hb");
c->addFullfillment("Localization::DeadReckoning");
c->addFullfillment("Base::VelocitySrv");
c->addFullfillment("Base::VelocitySrv");
}
{
auto c = new Composition("AuvControl::JoystickCommandCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::RawCommandControllerSrv"),"rawCommand");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addChild(pool->getComponent("RawControlCommandConverter::Movement"),"rawCommandConverter");
c->addChild(pool->getComponent("Base::GroundDistanceSrv"),"dist");
c->addFullfillment("AuvControl::JoystickCommandCmp");
c->addFullfillment("Base::AUVMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::WorldXYVelocityControllerSrv");
c->addFullfillment("Base::AUVMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::WorldXYVelocityControllerSrv");
}
{
auto c = new Composition("AuvControl::SimplePosMove");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("x", ConfigurationModel::DOUBLE);
	c->addProperty("y", ConfigurationModel::DOUBLE);
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("depth", ConfigurationModel::DOUBLE);
	c->addProperty("heading", ConfigurationModel::DOUBLE);
	c->addProperty("delta_timeout", ConfigurationModel::DOUBLE);
	c->addProperty("finish_when_reached", ConfigurationModel::BOOL);
	c->addProperty("event_on_timeout", ConfigurationModel::STRING);
	c->addProperty("delta_z", ConfigurationModel::DOUBLE);
	c->addProperty("delta_yaw", ConfigurationModel::DOUBLE);
	c->addProperty("delta_xy", ConfigurationModel::DOUBLE);
c->addChild(pool->getComponent("AvalonControl::RelFakeWriter"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addFullfillment("AuvControl::SimplePosMove");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("Base::ControlLoop");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::ControllerSrv"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("LowLevel::Cmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("LowLevelDriver::LowLevelTask"),"ll");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"z");
c->addFullfillment("LowLevel::Cmp");
}
{
auto c = new Composition("Localization::SonarFeatureDetectorCmp");
c->addEvent("reached_target");
c->addEvent("servoing_finished");
c->addEvent("not_enough_targets");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("SonarFeatureDetector::Task"),"sonar_detector");
c->addFullfillment("Localization::SonarFeatureDetectorCmp");
c->addFullfillment("Base::WorldXYZRollPitchYawControllerSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControllerSrv");
}
{
auto c = new Composition("Localization::FixMapHack");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("SonarFeatureDetector::Task"),"sonar_detector");
c->addFullfillment("Localization::FixMapHack");
}
{
auto c = new Composition("blueview_cmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("VideoStreamerVlc::Streamer"),"vlc");
c->addChild(pool->getComponent("Dev::Sensors::BlueView"),"camera");
c->addFullfillment("blueview_cmp");
}
{
auto c = new Composition("Buoy::DetectorCmp<Base::ControllerSrv>");
c->addEvent("buoy_search");
c->addEvent("buoy_detected");
c->addEvent("buoy_arrived");
c->addEvent("buoy_lost");
c->addEvent("strafing");
c->addEvent("strafe_finished");
c->addEvent("strafe_to_angle");
c->addEvent("angle_arrived");
c->addEvent("timeout");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"camera");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addChild(pool->getComponent("Buoy::Detector"),"detector");
c->addFullfillment("Buoy::DetectorCmp");
c->addFullfillment("Base::ControllerSrv");
}
{
auto c = new Composition("front_camera_cmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("VideoStreamerVlc::Streamer"),"vlc");
c->addChild(pool->getComponent("Dev::Sensors::Cameras::Prosilica"),"camera");
c->addFullfillment("front_camera_cmp");
}
{
auto c = new Composition("bottom_camera_cmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("VideoStreamerVlc::Streamer"),"vlc");
c->addChild(pool->getComponent("Dev::Sensors::Cameras::Prosilica"),"camera");
c->addFullfillment("bottom_camera_cmp");
}
{
auto c = new Composition("AuvCont::WorldXYZPositionCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addChild(pool->getComponent("Base::WorldXYZPositionControllerSrv"),"controller");
c->addFullfillment("AuvCont::WorldXYZPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::JointsCommandSrv");
}
{
auto c = new Composition("AuvCont::BuoyWallCmp");
c->addEvent("aligned");
c->addEvent("aligning");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::WorldXYZPositionControllerSrv"),"main");
c->addChild(pool->getComponent("Base::WorldXYZPositionControllerSrv"),"controller");
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addFullfillment("AuvCont::BuoyWallCmp");
c->addFullfillment("AuvCont::WorldXYZPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("AuvCont::WorldXYZPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::JointsCommandSrv");
}
{
auto c = new Composition("Modem::ModemCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Dev::ASVModem"),"main");
c->addFullfillment("Modem::ModemCmp");
}
{
auto c = new Composition("GPSHelper::GPSWaypointsCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("GpsHelper::WaypointNavigation"),"main");
c->addChild(pool->getComponent("Base::PositionSrv"),"gps");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addFullfillment("GPSHelper::GPSWaypointsCmp");
c->addFullfillment("Base::WorldXYZRollPitchYawControllerSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControllerSrv");
}
{
auto c = new Composition("Structure::Alignment");
c->addEvent("aligning");
c->addEvent("aligned");
c->addEvent("no_structure");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("StructureServoing::Alignment"),"detector");
c->addChild(pool->getComponent("HsvMosaicing::Task"),"mosaic");
c->addChild(pool->getComponent("ImagePreprocessing::HSVSegmentationAndBlur"),"seg");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"camera");
c->addFullfillment("Structure::Alignment");
c->addFullfillment("Base::WorldXYVelocityControllerSrv");
c->addFullfillment("Base::WorldXYVelocityControllerSrv");
}
{
auto c = new Composition("Structure::Detector");
c->addEvent("servoing");
c->addEvent("no_structure");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("rounds", ConfigurationModel::DOUBLE);
c->addChild(pool->getComponent("StructureServoing::Task"),"detector");
c->addChild(pool->getComponent("HsvMosaicing::Task"),"mosaic");
c->addChild(pool->getComponent("ImagePreprocessing::HSVSegmentationAndBlur"),"seg");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"camera");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"ori");
c->addFullfillment("Structure::Detector");
c->addFullfillment("Base::WorldXYVelocityControllerSrv");
c->addFullfillment("Base::WorldXYVelocityControllerSrv");
}
{
auto c = new Composition("Structure::SonarStructureServoingComp");
c->addEvent("MISSING_TRANSFORMATION");
c->addEvent("SEARCHING_STRUCTURE");
c->addEvent("VALIDATING_STRUCTURE");
c->addEvent("INSPECTING_STRUCTURE");
c->addEvent("SUCCESS");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("SonarStructureServoing::Task"),"detector");
c->addChild(pool->getComponent("Base::SonarScanProviderSrv"),"sonar");
c->addChild(pool->getComponent("SonarFeatureEstimator::Task"),"sonar_estimator");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose_blind");
c->addFullfillment("Structure::SonarStructureServoingComp");
c->addFullfillment("Base::AUVRelativeMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::WorldXYPositionControllerSrv");
c->addFullfillment("Base::AUVRelativeMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::WorldXYPositionControllerSrv");
}
{
auto c = new Composition("Structure::StructureReconstructionComp");
c->addEvent("MISSING_TRANSFORMATION");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("StructureReconstruction::Task"),"image_saver");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"front_camera");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"bottom_camera");
c->addFullfillment("Structure::StructureReconstructionComp");
}
{
auto c = new Composition("Buoy::DetectorCmp<Base::AUVRelativeMotionControllerSrv>");
c->addEvent("buoy_search");
c->addEvent("buoy_detected");
c->addEvent("buoy_arrived");
c->addEvent("buoy_lost");
c->addEvent("strafing");
c->addEvent("strafe_finished");
c->addEvent("strafe_to_angle");
c->addEvent("angle_arrived");
c->addEvent("timeout");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::ImageProviderSrv"),"camera");
c->addChild(pool->getComponent("Base::OrientationWithZSrv"),"orientation_with_z");
c->addChild(pool->getComponent("Buoy::Detector"),"detector");
c->addFullfillment("Buoy::DetectorCmp");
c->addFullfillment("Base::AUVRelativeMotionControllerSrv");
c->addFullfillment("Base::ControllerSrv");
c->addFullfillment("Base::ControllerSrv");
}
{
auto c = new Composition("AuvCont::ConstantCommandGroundAvoidanceCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("AuvControl::ConstantCommandGroundAvoidance"),"main");
c->addChild(pool->getComponent("Base::GroundDistanceSrv"),"altimeter");
c->addChild(pool->getComponent("Base::ZProviderSrv"),"depth");
c->addFullfillment("AuvCont::ConstantCommandGroundAvoidanceCmp");
}
{
auto c = new Composition("AuvCont::WorldPositionCmp");
c->addEvent("reached_target");
c->addEvent("servoing_finished");
c->addEvent("not_enough_targets");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("AuvCont::ConstantCommandGroundAvoidanceCmp"),"avoid");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addChild(pool->getComponent("Base::WorldXYZRollPitchYawControllerSrv"),"controller");
c->addFullfillment("AuvCont::WorldPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControlledSystemSrv");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControlledSystemSrv");
}
{
auto c = new Composition("Buoy::FollowerCmp");
c->addEvent("buoy_search");
c->addEvent("buoy_detected");
c->addEvent("buoy_arrived");
c->addEvent("buoy_lost");
c->addEvent("strafing");
c->addEvent("strafe_finished");
c->addEvent("strafe_to_angle");
c->addEvent("angle_arrived");
c->addEvent("timeout");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Buoy::DetectorCmp"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("Buoy::DetectorCmp"),"controller_local");
c->addFullfillment("Buoy::FollowerCmp");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("Buoy::DoubleBuoyCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::MapSrv"),"main");
c->addChild(pool->getComponent("Buoy::DetectorCmp"),"orange");
c->addChild(pool->getComponent("Buoy::DetectorCmp2"),"white");
c->addFullfillment("Buoy::DoubleBuoyCmp");
}
{
auto c = new Composition("PoseAuv::InitialOrientationEstimatorCmp");
c->addEvent("MISSING_TRANSFORMATION");
c->addEvent("ESTIMATE_WALL_ORIENTATION");
c->addEvent("VALID_WALL_FIX");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("WallOrientationCorrection::Task"),"wall_estimation");
c->addChild(pool->getComponent("OrientationEstimator::BaseEstimator"),"estimator");
c->addChild(pool->getComponent("XsensImu::Task"),"imu");
c->addChild(pool->getComponent("FogKvh::Dsp3000Task"),"fog");
c->addChild(pool->getComponent("Base::SonarScanProviderSrv"),"sonar");
c->addChild(pool->getComponent("SonarFeatureEstimator::Task"),"sonar_estimator");
c->addChild(pool->getComponent("PoseAuv::IKFOrientationEstimatorCmp"),"slave");
c->addFullfillment("PoseAuv::InitialOrientationEstimatorCmp");
}
{
auto c = new Composition("Buoy::ControllerNewCmp");
c->addEvent("passive_buoy_searching");
c->addEvent("buoy_servoing");
c->addEvent("aligned");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
c->addChild(pool->getComponent("Buoy::ServoingOnWall"),"main");
c->addChild(pool->getComponent("WallServoing::WallOrientationSrv"),"wall");
c->addChild(pool->getComponent("Base::OrientationSrv"),"pose");
c->addChild(pool->getComponent("Buoy::DetectorNewCmp"),"detector");
c->addFullfillment("Buoy::ControllerNewCmp");
c->addFullfillment("Base::WorldXYZPositionControllerSrv");
c->addFullfillment("Base::WorldXYZPositionControllerSrv");
}
{
auto c = new Composition("ConstantWorldXYVelocityCommand");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("AuvControl::ConstantCommand"),"controller_w");
c->addChild(pool->getComponent("ConsWA"),"controller_v");
c->addFullfillment("ConstantWorldXYVelocityCommand");
c->addFullfillment("Base::WorldXYVelocityControllerSrv");
c->addFullfillment("Base::WorldXYVelocityControllerSrv");
}
{
auto c = new Composition("Wall::Follower");
c->addEvent("wall_servoing");
c->addEvent("searching_wall");
c->addEvent("checking_wall");
c->addEvent("detected_corner");
c->addEvent("lost_all");
c->addEvent("origin_alignment");
c->addEvent("alignment_complete");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("max_corners", ConfigurationModel::INT);
c->addChild(pool->getComponent("Wall::Detector"),"controller");
c->addChild(pool->getComponent("Base::ControlledSystemSrv"),"controlled_system");
c->addChild(pool->getComponent("Wall::Detector"),"controller_local");
c->addFullfillment("Wall::Follower");
c->addFullfillment("Base::ControlLoop");
c->addFullfillment("Base::ControlLoop");
}
{
auto c = new Composition("AuvCont::WorldXYVelocityCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("AuvCont::ConstantCommandGroundAvoidanceCmp"),"avoid");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addChild(pool->getComponent("Base::WorldXYVelocityControllerSrv"),"controller");
c->addFullfillment("AuvCont::WorldXYVelocityCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::JointsCommandSrv");
}
{
auto c = new Composition("AuvCont::WorldXYPositionCmp");
c->addEvent("detected_corner");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("corners", ConfigurationModel::INT);
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("AuvCont::ConstantCommandGroundAvoidanceCmp"),"avoid");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addChild(pool->getComponent("Base::WorldXYPositionControllerSrv"),"controller");
c->addFullfillment("AuvCont::WorldXYPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::JointsCommandSrv");
}
{
auto c = new Composition("AuvCont::WorldYPositionXVelocityCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("AuvCont::ConstantCommandGroundAvoidanceCmp"),"avoid");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addChild(pool->getComponent("Base::WorldYPositionXVelocityControllerSrv"),"controller");
c->addFullfillment("AuvCont::WorldYPositionXVelocityCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::JointsCommandSrv");
}
{
auto c = new Composition("AuvCont::Trajectory");
c->addEvent("reached_end");
c->addEvent("align_at_end");
c->addEvent("reached_target");
c->addEvent("servoing_finished");
c->addEvent("not_enough_targets");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("reset", ConfigurationModel::BOOL);
c->addChild(pool->getComponent("AvalonControl::TrajectoryFollower"),"main");
c->addChild(pool->getComponent("AvalonControl::TrajectoryFollower"),"controller");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("AuvCont::ConstantCommandGroundAvoidanceCmp"),"avoid");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addFullfillment("AuvCont::Trajectory");
c->addFullfillment("AuvCont::WorldPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControlledSystemSrv");
c->addFullfillment("AuvCont::WorldPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControlledSystemSrv");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControlledSystemSrv");
}
{
auto c = new Composition("AuvCont::PositionMoveCmp");
c->addEvent("reached_target");
c->addEvent("servoing_finished");
c->addEvent("not_enough_targets");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("x", ConfigurationModel::DOUBLE);
	c->addProperty("y", ConfigurationModel::DOUBLE);
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("depth", ConfigurationModel::DOUBLE);
	c->addProperty("heading", ConfigurationModel::DOUBLE);
	c->addProperty("delta_timeout", ConfigurationModel::DOUBLE);
	c->addProperty("finish_when_reached", ConfigurationModel::BOOL);
	c->addProperty("event_on_timeout", ConfigurationModel::STRING);
	c->addProperty("delta_z", ConfigurationModel::DOUBLE);
	c->addProperty("delta_yaw", ConfigurationModel::DOUBLE);
	c->addProperty("delta_xy", ConfigurationModel::DOUBLE);
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
c->addChild(pool->getComponent("AuvControl::ConstantCommand"),"command");
c->addChild(pool->getComponent("AuvControl::ConstantCommand"),"controller");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("AuvCont::ConstantCommandGroundAvoidanceCmp"),"avoid");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addFullfillment("AuvCont::PositionMoveCmp");
c->addFullfillment("AuvCont::WorldPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControlledSystemSrv");
c->addFullfillment("AuvCont::WorldPositionCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControlledSystemSrv");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::WorldXYZRollPitchYawControlledSystemSrv");
}
{
auto c = new Composition("AuvCont::MoveCmp");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
	c->addProperty("depth", ConfigurationModel::DOUBLE);
	c->addProperty("heading", ConfigurationModel::DOUBLE);
	c->addProperty("delta_timeout", ConfigurationModel::DOUBLE);
	c->addProperty("speed_x", ConfigurationModel::DOUBLE);
	c->addProperty("speed_y", ConfigurationModel::DOUBLE);
	c->addProperty("finish_when_reached", ConfigurationModel::BOOL);
	c->addProperty("event_on_timeout", ConfigurationModel::STRING);
	c->addProperty("delta_z", ConfigurationModel::DOUBLE);
	c->addProperty("delta_yaw", ConfigurationModel::DOUBLE);
	c->addProperty("delta_xy", ConfigurationModel::DOUBLE);
c->addChild(pool->getComponent("ConstantWorldXYVelocityCommand"),"command");
c->addChild(pool->getComponent("ConstantWorldXYVelocityCommand"),"controller");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("AuvCont::ConstantCommandGroundAvoidanceCmp"),"avoid");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addFullfillment("AuvCont::MoveCmp");
c->addFullfillment("AuvCont::WorldXYVelocityCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("AuvCont::WorldXYVelocityCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::JointsCommandSrv");
}
{
auto c = new Composition("AuvCont::StructureCmp");
c->addEvent("aligned");
c->addEvent("aligning");
c->addEvent("servoing");
c->addEvent("no_structure");
c->addEvent("failed");
c->addEvent("stop");
c->addEvent("start");
c->addEvent("success");
c->addEvent("aborted");
c->addEvent("internal_error");
c->addEvent("updated_data");
c->addEvent("poll_transition");
	c->addProperty("timeout", ConfigurationModel::DOUBLE);
c->addChild(pool->getComponent("Base::WorldXYVelocityControllerSrv"),"main");
c->addChild(pool->getComponent("Base::WorldXYVelocityControllerSrv"),"controller");
c->addChild(pool->getComponent("Base::PoseSrv"),"pose");
c->addChild(pool->getComponent("Base::JointsControlledSystemSrv"),"joint");
c->addChild(pool->getComponent("AuvCont::ConstantCommandGroundAvoidanceCmp"),"avoid");
c->addChild(pool->getComponent("AuvControl::WorldToAligned"),"world_to_aligned");
c->addChild(pool->getComponent("AuvControl::OptimalHeadingController"),"optimal_heading_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_position_controller");
c->addChild(pool->getComponent("AuvControl::PIDController"),"aligned_velocity_controller");
c->addChild(pool->getComponent("AuvControl::AccelerationController"),"acceleration_controller");
c->addChild(pool->getComponent("AuvControl::AlignedToBody"),"aligned_to_body");
c->addFullfillment("AuvCont::StructureCmp");
c->addFullfillment("AuvCont::WorldXYVelocityCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("AuvCont::WorldXYVelocityCmp");
c->addFullfillment("Base::JointsCommandSrv");
c->addFullfillment("Base::JointsCommandSrv");
}
load_constraints();
return "";
}
